"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.abstractSqlToTypescriptTypes = void 0;
const odata_to_abstract_sql_1 = require("@balena/odata-to-abstract-sql");
const common_tags_1 = require("common-tags");
const package_json_1 = require("../package.json");
const trimNL = new common_tags_1.TemplateTag((0, common_tags_1.replaceResultTransformer)(/^[\r\n]*|[\r\n]*$/g, ''));
const modelNameToCamelCaseName = (s) => s
    .split(/[ -]/)
    .map((p) => p[0].toLocaleUpperCase() + p.slice(1))
    .join('');
const getReferencedInterface = (modelName, mode) => `${modelNameToCamelCaseName(modelName)}['${mode}']`;
const sqlTypeToTypescriptType = (m, f, mode) => {
    if (!['ForeignKey', 'ConceptType'].includes(f.dataType) && f.checks) {
        const inChecks = f.checks.find((checkTuple) => checkTuple[0] === 'In');
        if (inChecks) {
            const [, , ...allowedValues] = inChecks;
            return allowedValues
                .map(([type, value]) => (type === 'Text' ? `'${value}'` : value))
                .join(' | ');
        }
    }
    switch (f.dataType) {
        case 'ConceptType':
        case 'ForeignKey': {
            const referencedInterface = getReferencedInterface(m.tables[f.references.resourceName].name, mode);
            const referencedFieldType = `${referencedInterface}['${f.references.fieldName}']`;
            if (mode === 'Write') {
                return referencedFieldType;
            }
            const nullable = f.required ? '' : ' | []';
            return `{ __id: ${referencedFieldType} } | [${referencedInterface}]${nullable}`;
        }
        default:
            return `Types['${f.dataType}']['${mode}']`;
    }
};
const fieldToInterfaceProps = (key, m, f, mode) => {
    if (mode === 'Write' && f.computed != null) {
        return;
    }
    const nullable = f.required ? '' : ' | null';
    return `${(0, odata_to_abstract_sql_1.sqlNameToODataName)(key)}: ${sqlTypeToTypescriptType(m, f, mode)}${nullable};`;
};
const fieldsToInterfaceProps = (m, fields, mode) => fields
    .map((f) => fieldToInterfaceProps(f.fieldName, m, f, mode))
    .filter((f) => f != null);
const getSynonyms = (s, inverseSynonyms) => {
    const synonyms = [];
    for (const inverseSynonym of Object.keys(inverseSynonyms)) {
        if (s.includes(inverseSynonym)) {
            synonyms.push(s.replace(inverseSynonym, inverseSynonyms[inverseSynonym]));
        }
    }
    return synonyms;
};
const recurseRelationships = (m, relationships, inverseSynonyms, mode, currentTable, parentKey) => Object.keys(relationships).flatMap((key) => {
    if (key === '$') {
        const [localField, referencedField] = relationships.$;
        if (referencedField != null) {
            if (currentTable.idField === localField) {
                const referencedTable = m.tables[referencedField[0]];
                if (referencedTable != null) {
                    const referencedInterface = getReferencedInterface(referencedTable.name, mode);
                    const propDefinitons = [
                        `${(0, odata_to_abstract_sql_1.sqlNameToODataName)(parentKey)}?: Array<${referencedInterface}>;`,
                    ];
                    const synonyms = getSynonyms(parentKey, inverseSynonyms);
                    if (synonyms.length > 0) {
                        for (const synonym of synonyms) {
                            propDefinitons.push(`${(0, odata_to_abstract_sql_1.sqlNameToODataName)(synonym)}?: Array<${referencedInterface}>;`);
                        }
                    }
                    return propDefinitons;
                }
            }
            else {
                const f = currentTable.fields.find(({ fieldName }) => fieldName === localField);
                const propDefinitons = [];
                const addDefinition = (propName) => {
                    if (f.fieldName !== propName) {
                        const propDefiniton = fieldToInterfaceProps(propName, m, f, mode);
                        if (propDefiniton != null) {
                            propDefinitons.push(propDefiniton);
                        }
                    }
                };
                addDefinition(parentKey);
                const synonyms = getSynonyms(parentKey, inverseSynonyms);
                if (synonyms.length > 0) {
                    for (const synonym of synonyms) {
                        addDefinition(synonym);
                    }
                }
                return propDefinitons;
            }
        }
        return [];
    }
    return recurseRelationships(m, relationships[key], inverseSynonyms, mode, currentTable, `${parentKey}-${key}`);
});
const relationshipsToInterfaceProps = (m, table, mode) => {
    const relationships = m.relationships[table.resourceName];
    if (relationships == null) {
        return [];
    }
    return Object.keys(relationships).flatMap((key) => {
        if (key === 'has') {
            return [];
        }
        const inverseSynonyms = Object.fromEntries(Object.entries(m.synonyms).map(([termForm, factType]) => [
            factType,
            termForm,
        ]));
        return recurseRelationships(m, relationships[key], inverseSynonyms, mode, table, key);
    });
};
const tableToInterface = (m, table) => {
    const writableFields = table.definition != null
        ? []
        : fieldsToInterfaceProps(m, table.fields, 'Write');
    const writeType = writableFields.length === 0
        ?
            'Record<string, never>'
        : `{
		${writableFields.join('\n\t\t')}
	}`;
    return trimNL `
export interface ${modelNameToCamelCaseName(table.name)} {
	Read: {
		${[
        ...fieldsToInterfaceProps(m, table.fields, 'Read'),
        ...relationshipsToInterfaceProps(m, table, 'Read'),
    ].join('\n\t\t')}
	};
	Write: ${writeType};
}
`;
};
const abstractSqlToTypescriptTypes = (m) => {
    return trimNL `
// These types were generated by @balena/abstract-sql-to-typescript v${package_json_1.version}

import type { Types } from '@balena/abstract-sql-to-typescript';

${Object.keys(m.tables)
        .map((tableName) => {
        const t = m.tables[tableName];
        return tableToInterface(m, t);
    })
        .join('\n\n')}

export default interface $Model {
${Object.keys(m.tables)
        .map((tableName) => `	${(0, odata_to_abstract_sql_1.sqlNameToODataName)(tableName)}: ${modelNameToCamelCaseName(m.tables[tableName].name)};`)
        .join('\n')}
${Object.keys(m.synonyms).length > 0 ? '	// Synonyms' : ''}
${Object.keys(m.synonyms)
        .map((synonym) => `	${(0, odata_to_abstract_sql_1.sqlNameToODataName)(synonym)}: ${modelNameToCamelCaseName(m.tables[m.synonyms[synonym]].name)};`)
        .join('\n')}
}
`;
};
exports.abstractSqlToTypescriptTypes = abstractSqlToTypescriptTypes;
//# sourceMappingURL=generate.js.map