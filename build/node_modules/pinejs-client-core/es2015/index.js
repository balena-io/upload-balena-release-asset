"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinejsClientCore = void 0;
function isArray(value) {
    // See: https://github.com/microsoft/TypeScript/issues/17002
    return Array.isArray(value);
}
const noop = () => {
    // noop
};
const deprecated = (() => {
    const deprecationMessages = {
        expandFilter: '`$filter: a: b: ...` is deprecated, please use `$filter: a: $any: { $alias: "x", $expr: x: b: ... }` instead.',
        countInResource: "'`resource: 'a/$count'` is deprecated, please use `options: { $count: { ... } }` instead.",
        countInExpand: "'`$expand: { 'a/$count': {...} }` is deprecated, please use `$expand: { a: { $count: {...} } }` instead.",
        countWithNestedOperationInFilter: "'`$filter: { a: { $count: { $op: number } } }` is deprecated, please use `$filter: { $eq: [ { a: { $count: {} } }, number ] }` instead.",
        countInOrderBy: "'`$orderby: 'a/$count'` is deprecated, please use `$orderby: { a: { $count: {...} } }` instead.",
        non$filterOptionIn$expand$count: 'using OData options other than $filter in a `$expand: { a: { $count: {...} } }` is deprecated, please remove them.',
        urlInGetOrCreate: 'Passing `url` to `getOrCreate` is deprecated as it is unsupported and may have adverse effects, please use a query object instead.',
        urlInUpsert: 'Passing `url` to `upsert` is deprecated as it is unsupported and may have adverse effects, please use a query object instead.',
        urlInCompile: 'Passing `url` to `compile` is deprecated, please use a query object instead or use `request` directly.',
        urlInGet: 'Passing `url` to `get` is deprecated, please use a query object instead or use `request` directly.',
        urlInPost: 'Passing `url` to `post` is deprecated, please use a query object instead or use `request` directly.',
        urlInPatch: 'Passing `url` to `patch` is deprecated, please use a query object instead or use `request` directly.',
        urlInPut: 'Passing `url` to `put` is deprecated, please use a query object instead or use `request` directly.',
        urlInDelete: 'Passing `url` to `delete` is deprecated, please use a query object instead or use `request` directly.',
    };
    const result = {};
    for (const key of Object.keys(deprecationMessages)) {
        result[key] = () => {
            console.warn('pinejs-client deprecated:', deprecationMessages[key]);
            result[key] = noop;
        };
    }
    return result;
})();
const mapObj = (obj, fn) => Object.keys(obj).map((key) => fn(obj[key], key));
const NumberIsFinite = Number.isFinite || ((v) => typeof v === 'number' && isFinite(v));
const isString = (v) => typeof v === 'string';
const isBoolean = (v) => v === true || v === false;
const isDate = (v) => Object.prototype.toString.call(v) === '[object Date]';
const isObject = (v) => v != null && typeof v === 'object';
const isValidOption = (key) => {
    return (key === '$select' ||
        key === '$filter' ||
        key === '$expand' ||
        key === '$orderby' ||
        key === '$top' ||
        key === '$skip' ||
        key === '$format');
};
const encodedSlash = encodeURIComponent('/');
const encodedCount = encodeURIComponent('$count');
const trailingCountRegex = new RegExp(`(?:(?:${encodedSlash})|/)${encodedCount}$`);
const ODataOptionCodeExampleMap = {
    $filter: '$filter: a: $op: [b: $count: ... ]',
    $expand: '$expand: a: $count: ...',
    $orderby: "$orderby: { a: { $count: ... }, $dir: 'asc' }",
};
const durationTimepartFlagEntries = [
    ['hours', 'H'],
    ['minutes', 'M'],
    ['seconds', 'S'],
];
class Poll {
    constructor(requestFn, intervalTime = 10000) {
        this.intervalTime = intervalTime;
        this.subscribers = {
            error: [],
            data: [],
        };
        this.stopped = false;
        this.requestFn = requestFn;
        this.start();
    }
    setPollInterval(intervalTime) {
        this.intervalTime = intervalTime;
        this.restartTimeout();
    }
    runRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.stopped || this.requestFn == null) {
                return;
            }
            try {
                const response = yield this.requestFn();
                if (this.stopped) {
                    return;
                }
                this.restartTimeout();
                // Catch errors in event subscribers so that they don't trigger
                // the 'catch' below, and that subsequent subscribers will still
                // be called
                this.subscribers.data.forEach((fn) => {
                    try {
                        fn(response);
                    }
                    catch (error) {
                        console.error('pinejs-client error: Caught error in data event subscription:', error);
                    }
                });
            }
            catch (err) {
                if (this.stopped) {
                    return;
                }
                this.restartTimeout();
                this.subscribers.error.forEach((fn) => {
                    try {
                        fn(err);
                    }
                    catch (error) {
                        console.error('pinejs-client error: Caught error in error event subscription:', error);
                    }
                });
            }
        });
    }
    on(name, fn) {
        const subscribers = this.subscribers[name];
        const index = subscribers.push(fn) - 1;
        return {
            unsubscribe: () => delete this.subscribers[name][index],
        };
    }
    start() {
        this.stopped = false;
        void this.runRequest();
    }
    stop() {
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
        }
        this.stopped = true;
    }
    destroy() {
        this.stop();
        this.requestFn = null;
        this.subscribers.error.length = 0;
        this.subscribers.data.length = 0;
    }
    restartTimeout() {
        if (this.stopped) {
            return;
        }
        if (this.pollInterval) {
            clearTimeout(this.pollInterval);
        }
        this.pollInterval = setTimeout(() => this.runRequest(), this.intervalTime);
    }
}
const isPrimitive = (value) => {
    return (value === null ||
        isString(value) ||
        NumberIsFinite(value) ||
        isBoolean(value) ||
        isDate(value));
};
// Escape a resource name (string), or resource path (array)
const escapeResource = (resource) => {
    if (isString(resource)) {
        resource = encodeURIComponent(resource);
    }
    else if (isArray(resource)) {
        resource = resource.map(encodeURIComponent).join('/');
    }
    else {
        throw new Error('Not a valid resource: ' + typeof resource);
    }
    return resource.replace(trailingCountRegex, '/$count');
};
// Escape a primitive value
const escapeValue = (value) => {
    if (isString(value)) {
        value = value.replace(/'/g, "''");
        return `'${encodeURIComponent(value)}'`;
    }
    else if (isDate(value)) {
        return `datetime'${value.toISOString()}'`;
    }
    else if (value === null || NumberIsFinite(value) || isBoolean(value)) {
        return value;
    }
    else {
        throw new Error('Not a valid value: ' + typeof value);
    }
};
const escapeParameterAlias = (value) => {
    if (!isString(value)) {
        throw new Error(`Parameter alias reference must be a string, got: ${typeof value}`);
    }
    return `@${encodeURIComponent(value)}`;
};
const join = (strOrArray, separator = ',') => {
    if (isString(strOrArray)) {
        return strOrArray;
    }
    else if (isArray(strOrArray)) {
        return strOrArray.join(separator);
    }
    else {
        throw new Error('Expected a string or array, got: ' + typeof strOrArray);
    }
};
// Join together a bunch of statements making sure the whole lot is correctly parenthesised
const bracketJoin = (arr, separator) => {
    if (arr.length === 1) {
        return arr[0];
    }
    const resultArr = [];
    arr
        .map((subArr) => {
        if (subArr.length > 1) {
            return `(${subArr.join('')})`;
        }
        return subArr[0];
    })
        .forEach((str, i) => {
        if (i !== 0) {
            resultArr.push(separator);
        }
        resultArr.push(str);
    });
    return resultArr;
};
// Add the parentKey + operator if it exists.
const addParentKey = (filter, parentKey, operator = ' eq ') => {
    if (parentKey != null) {
        if (isArray(filter)) {
            if (filter.length === 1) {
                filter = filter[0];
            }
            else {
                filter = `(${filter.join('')})`;
            }
        }
        else {
            filter = `${filter}`;
        }
        return [escapeResource(parentKey), operator, filter];
    }
    if (isArray(filter)) {
        return filter;
    }
    return [`${filter}`];
};
const applyBinds = (filter, params, parentKey) => {
    for (const index of Object.keys(params)) {
        const param = params[index];
        let paramStr = `(${buildFilter(param).join('')})`;
        // Escape $ for filter.replace
        paramStr = paramStr.replace(/\$/g, '$$$$');
        filter = filter.replace(new RegExp(`\\$${index}([^a-zA-Z0-9]|$)`, 'g'), `${paramStr}$1`);
    }
    filter = `(${filter})`;
    return addParentKey(filter, parentKey);
};
const filterOperation = (filter, operator, parentKey) => {
    const op = ' ' + operator.slice(1) + ' ';
    if (isPrimitive(filter)) {
        const filterStr = escapeValue(filter);
        return addParentKey(filterStr, parentKey, op);
    }
    else if (isArray(filter)) {
        const filterArr = handleFilterArray(filter);
        const filterStr = bracketJoin(filterArr, op);
        return addParentKey(filterStr, parentKey);
    }
    else if (isObject(filter)) {
        const result = handleFilterObject(filter);
        if (result.length < 1) {
            throw new Error(`${operator} objects must have at least 1 property, got: ${JSON.stringify(filter)}`);
        }
        if (result.length === 1) {
            return addParentKey(result[0], parentKey, op);
        }
        else {
            const filterStr = bracketJoin(result, op);
            return addParentKey(filterStr, parentKey);
        }
    }
    else {
        throw new Error('Expected null/string/number/bool/obj/array, got: ' + typeof filter);
    }
};
const filterFunction = (filter, fnIdentifier, parentKey) => {
    const fnName = fnIdentifier.slice(1);
    if (isPrimitive(filter)) {
        const operands = [];
        if (parentKey != null) {
            operands.push(escapeResource(parentKey));
        }
        operands.push(escapeValue(filter));
        return [`${fnName}(${operands.join()})`];
    }
    else if (isArray(filter)) {
        const filterArr = handleFilterArray(filter);
        let filterStr = filterArr.map((subArr) => subArr.join('')).join(',');
        filterStr = `${fnName}(${filterStr})`;
        return addParentKey(filterStr, parentKey);
    }
    else if (isObject(filter)) {
        const filterArr = handleFilterObject(filter);
        let filterStr = filterArr.map((subArr) => subArr.join('')).join(',');
        filterStr = `${fnName}(${filterStr})`;
        return addParentKey(filterStr, parentKey);
    }
    else {
        throw new Error(`Expected null/string/number/obj/array, got: ${typeof filter}`);
    }
};
// Handle special cases for all the different $ operators.
const handleFilterOperator = (filter, operator, parentKey) => {
    switch (operator) {
        case '$ne':
        case '$eq':
        case '$gt':
        case '$ge':
        case '$lt':
        case '$le':
        case '$add':
        case '$sub':
        case '$mul':
        case '$div':
        case '$mod':
            return filterOperation(filter, operator, parentKey);
        // break
        case '$contains':
        case '$endswith':
        case '$startswith':
        case '$length':
        case '$indexof':
        case '$substring':
        case '$tolower':
        case '$toupper':
        case '$trim':
        case '$concat':
        case '$year':
        case '$month':
        case '$day':
        case '$hour':
        case '$minute':
        case '$second':
        case '$fractionalseconds':
        case '$date':
        case '$time':
        case '$totaloffsetminutes':
        case '$now':
        case '$maxdatetime':
        case '$mindatetime':
        case '$totalseconds':
        case '$round':
        case '$floor':
        case '$ceiling':
        case '$isof':
        case '$cast':
            return filterFunction(filter, operator, parentKey);
        case '$duration': {
            const durationValue = filter;
            if (!isObject(durationValue)) {
                throw new Error(`Expected type for ${operator}, got: ${typeof filter}`);
            }
            let durationString = 'P';
            if (durationValue.days) {
                durationString += `${durationValue.days}D`;
            }
            let timePart = '';
            for (const [partKey, partFlag] of durationTimepartFlagEntries) {
                if (durationValue[partKey]) {
                    timePart += `${durationValue[partKey]}${partFlag}`;
                }
            }
            if (timePart.length > 0) {
                durationString += `T${timePart}`;
            }
            if (durationString.length <= 1) {
                throw new Error(`Expected ${operator} to include duration properties, got: ${typeof filter}`);
            }
            if (durationValue.negative) {
                durationString = `-${durationString}`;
            }
            return addParentKey(`duration'${durationString}'`, parentKey);
        }
        // break
        case '$raw': {
            const filterx = filter;
            if (isString(filterx)) {
                return addParentKey(`(${filterx})`, parentKey);
            }
            else if (!isPrimitive(filterx)) {
                // This needs to use the mutable version `Array.isArray` or otherwise the destructuring gets the wrong types?
                if (Array.isArray(filterx)) {
                    const [rawFilter, ...params] = filterx;
                    if (!isString(rawFilter)) {
                        throw new Error(`First element of array for ${operator} must be a string, got: ${typeof rawFilter}`);
                    }
                    const mappedParams = {};
                    for (let index = 0; index < params.length; index++) {
                        mappedParams[index + 1] = params[index];
                    }
                    return applyBinds(rawFilter, mappedParams, parentKey);
                }
                else if (isObject(filterx)) {
                    const filterStr = filterx.$string;
                    if (!isString(filterStr)) {
                        throw new Error(`$string element of object for ${operator} must be a string, got: ${typeof filterStr}`);
                    }
                    const mappedParams = {};
                    for (const index in filterx) {
                        if (index !== '$string') {
                            if (!/^[a-zA-Z0-9]+$/.test(index)) {
                                throw new Error(`${operator} param names must contain only [a-zA-Z0-9], got: ${index}`);
                            }
                            mappedParams[index] = filterx[index];
                        }
                    }
                    return applyBinds(filterStr, mappedParams, parentKey);
                }
            }
            throw new Error(`Expected string/array/object for ${operator}, got: ${typeof filterx}`);
        }
        // break
        case '$': {
            const resource = escapeResource(filter);
            return addParentKey(resource, parentKey);
        }
        case '$count': {
            let keys = ['$count'];
            if (parentKey != null &&
                isObject(filter) &&
                // Handles the `$filter: $op: [ {a: {$count: {'...'}}}, value]`` case.
                (Object.keys(filter).length === 0 ||
                    Object.prototype.hasOwnProperty.call(filter, '$filter'))) {
                keys = parentKey.slice(0, parentKey.length - 1);
                keys.push(handleOptions('$filter', { $count: filter }, parentKey[parentKey.length - 1]));
                return [keys.join('/')];
            }
            if (parentKey != null) {
                keys = parentKey.concat(keys);
            }
            // Handles the `$filter: a: $count: value` case.
            deprecated.countWithNestedOperationInFilter();
            return buildFilter(filter, keys);
        }
        // break
        case '$and':
        case '$or': {
            const filterStr = buildFilter(filter, undefined, ` ${operator.slice(1)} `);
            return addParentKey(filterStr, parentKey);
        }
        // break
        case '$in': {
            filter = filter;
            if (isPrimitive(filter)) {
                const filterStr = escapeValue(filter);
                return addParentKey(filterStr, parentKey, ' eq ');
            }
            else if (isArray(filter)) {
                if (filter.every(isPrimitive)) {
                    const filterStr = handleFilterArray(filter, undefined, 1);
                    const inStr = bracketJoin(filterStr, ', ').join('');
                    return addParentKey(`(${inStr})`, parentKey, ' in ');
                }
                else {
                    const filterStr = handleFilterArray(filter, parentKey, 1);
                    return bracketJoin(filterStr, ' or ');
                }
            }
            else if (isObject(filter)) {
                const filterArr = handleFilterObject(filter, parentKey);
                if (filterArr.length < 1) {
                    throw new Error(`${operator} objects must have at least 1 property, got: ${JSON.stringify(filter)}`);
                }
                return bracketJoin(filterArr, ' or ');
            }
            else {
                throw new Error(`Expected null/string/number/bool/obj/array, got: ${typeof filter}`);
            }
        }
        // break
        case '$not': {
            const filterStr = `not(${buildFilter(filter).join('')})`;
            return addParentKey(filterStr, parentKey);
        }
        // break
        case '$any':
        case '$all': {
            const filterx = filter;
            const alias = filterx.$alias;
            const expr = filterx.$expr;
            if (alias == null) {
                throw new Error(`Lambda expression (${operator}) has no alias defined.`);
            }
            if (expr == null) {
                throw new Error(`Lambda expression (${operator}) has no expr defined.`);
            }
            // Disable the expandFilter deprecation notice when inside a lambda expr
            const deprecatedFn = (deprecated.expandFilter = noop);
            let filterStr;
            try {
                filterStr = buildFilter(expr).join('');
            }
            finally {
                deprecated.expandFilter = deprecatedFn;
            }
            filterStr = `${operator.slice(1)}(${alias}:${filterStr})`;
            return addParentKey(filterStr, parentKey, '/');
        }
        // break
        default:
            throw new Error(`Unrecognised operator: '${operator}'`);
    }
};
const handleFilterObject = (filter, parentKey) => {
    return mapObj(filter, (value, key) => {
        if (value === undefined) {
            throw new Error(`'${key}' was present on a filter object but undefined, did you mean to use null instead?`);
        }
        if (key.startsWith('$')) {
            return handleFilterOperator(value, key, parentKey);
        }
        else if (key.startsWith('@')) {
            const parameterAlias = escapeParameterAlias(value);
            return addParentKey(parameterAlias, parentKey);
        }
        else {
            let keys = [key];
            if (parentKey != null) {
                if (parentKey.length > 0) {
                    deprecated.expandFilter();
                }
                keys = parentKey.concat(keys);
            }
            return buildFilter(value, keys);
        }
    });
};
const handleFilterArray = (filter, parentKey, minElements = 2) => {
    if (filter.length < minElements) {
        throw new Error(`Filter arrays must have at least ${minElements} elements, got: ${JSON.stringify(filter)}`);
    }
    return filter.map((value) => {
        return buildFilter(value, parentKey);
    });
};
// Turn a filter query object into an OData $filter string
const buildFilter = (filter, parentKey, joinStr) => {
    if (isPrimitive(filter)) {
        const filterStr = escapeValue(filter);
        return addParentKey(filterStr, parentKey);
    }
    else if (isArray(filter)) {
        const filterArr = handleFilterArray(filter);
        const filterStr = bracketJoin(filterArr, joinStr !== null && joinStr !== void 0 ? joinStr : ' or ');
        return addParentKey(filterStr, parentKey);
    }
    else if (isObject(filter)) {
        const filterArr = handleFilterObject(filter, parentKey);
        return bracketJoin(filterArr, joinStr !== null && joinStr !== void 0 ? joinStr : ' and ');
    }
    else {
        throw new Error(`Expected null/string/number/obj/array, got: ${typeof filter}`);
    }
};
const buildOrderBy = (orderby) => {
    if (isString(orderby)) {
        if (/\/\$count\b/.test(orderby)) {
            deprecated.countInOrderBy();
        }
        return orderby;
    }
    else if (isArray(orderby)) {
        if (orderby.length === 0) {
            throw new Error(`'$orderby' arrays have to have at least 1 element`);
        }
        const result = orderby.map((value) => {
            if (isArray(value)) {
                throw new Error(`'$orderby' cannot have nested arrays`);
            }
            return buildOrderBy(value);
        });
        return join(result);
    }
    else if (isObject(orderby)) {
        const { $dir } = orderby, $orderby = __rest(orderby, ["$dir"]);
        const result = mapObj($orderby, (dirOrOptions, key) => {
            let propertyPath = key;
            let dir = $dir;
            if (dirOrOptions == null) {
                throw new Error(`Orderby object values must not be null, got null for ${key}`);
            }
            if (typeof dirOrOptions === 'string') {
                dir = dirOrOptions;
            }
            else {
                const keys = Object.keys(dirOrOptions);
                if (!Object.prototype.hasOwnProperty.call(dirOrOptions, '$count') ||
                    keys.length > 1) {
                    throw new Error(`When using '${ODataOptionCodeExampleMap['$orderby']}' you can only specify $count, got: '${JSON.stringify(keys)}'`);
                }
                propertyPath = handleOptions('$orderby', dirOrOptions, propertyPath);
            }
            if (dir == null) {
                throw new Error(`'$orderby' objects should either use the '{ a: 'asc' }' or the ${ODataOptionCodeExampleMap.$orderby} notation`);
            }
            if (dir !== 'asc' && dir !== 'desc') {
                throw new Error(`'$orderby' direction must be 'asc' or 'desc'`);
            }
            return `${propertyPath} ${dir}`;
        });
        if (result.length !== 1) {
            throw new Error(`'$orderby' objects must have exactly one element, got ${result.length} elements`);
        }
        return result[0];
    }
    else {
        throw new Error(`'$orderby' option has to be either a string, array, or object`);
    }
};
const buildOption = (option, value) => {
    let compiledValue = '';
    switch (option) {
        case '$filter':
            compiledValue = buildFilter(value).join('');
            break;
        case '$expand':
            compiledValue = buildExpand(value);
            break;
        case '$orderby':
            compiledValue = buildOrderBy(value);
            break;
        case '$top':
        case '$skip': {
            const num = value;
            if (!NumberIsFinite(num)) {
                throw new Error(`'${option}' option has to be a number`);
            }
            compiledValue = '' + num;
            break;
        }
        case '$select': {
            const select = value;
            if (isString(select)) {
                compiledValue = join(select);
            }
            else if (isArray(select)) {
                if (select.length === 0) {
                    throw new Error(`'${option}' arrays have to have at least 1 element`);
                }
                compiledValue = join(select);
            }
            else {
                throw new Error(`'${option}' option has to be either a string or array`);
            }
            break;
        }
        default:
            // Escape parameter aliases as primitives
            if (option.startsWith('@')) {
                if (!isPrimitive(value)) {
                    throw new Error(`Unknown type for parameter alias option '${option}': ${typeof value}`);
                }
                compiledValue = '' + escapeValue(value);
            }
            // Unknown values are left as-is
            else if (isArray(value)) {
                compiledValue = join(value);
            }
            else if (isString(value)) {
                compiledValue = value;
            }
            else if (isBoolean(value) || NumberIsFinite(value)) {
                compiledValue = value.toString();
            }
            else {
                throw new Error(`Unknown type for option ${typeof value}`);
            }
    }
    return `${option}=${compiledValue}`;
};
const handleOptions = (optionOperation, options, parentKey) => {
    if (Object.prototype.hasOwnProperty.call(options, '$count')) {
        const keys = Object.keys(options);
        if (keys.length > 1) {
            throw new Error(`When using '${ODataOptionCodeExampleMap[optionOperation]}' you can only specify $count, got: '${JSON.stringify(keys)}'`);
        }
        options = options.$count;
        parentKey += '/$count';
        // Check whether there is anything else other than $filter in the $count
        // and error b/c it's invalid.
        if (Object.keys(options).length >
            (Object.prototype.hasOwnProperty.call(options, '$filter') ? 1 : 0)) {
            // TODO: Remove the optionOperation check in the next major,
            // so that it throws for all operators.
            if (optionOperation === '$expand') {
                deprecated.non$filterOptionIn$expand$count();
            }
            else {
                throw new Error(`When using '${ODataOptionCodeExampleMap[optionOperation]}' you can only specify $filter in the $count, got: '${JSON.stringify(Object.keys(options))}'`);
            }
        }
    }
    const optionsArray = mapObj(options, (value, key) => {
        if (key.startsWith('$')) {
            if (!isValidOption(key)) {
                throw new Error(`Unknown key option '${key}'`);
            }
            return buildOption(key, value);
        }
        if (optionOperation === '$expand') {
            throw new Error(`'$expand: ${parentKey}: ${key}: ...' is invalid, use '$expand: ${parentKey}: $expand: ${key}: ...' instead.`);
        }
        throw new Error(`'${optionOperation}: ${parentKey}: ${key}: ...' is invalid.`);
    });
    let optionsStr = optionsArray.join(';');
    if (optionsStr.length > 0) {
        optionsStr = `(${optionsStr})`;
    }
    optionsStr = escapeResource(parentKey) + optionsStr;
    return optionsStr;
};
const handleExpandObject = (expand) => {
    const expands = mapObj(expand, (value, key) => {
        if (key.startsWith('$')) {
            throw new Error('Cannot have expand options without first expanding something!');
        }
        if (value == null) {
            throw new Error(`Expand object values must not be null, got null for ${key}`);
        }
        if (isPrimitive(value)) {
            const jsonValue = JSON.stringify(value);
            throw new Error(`'$expand: ${key}: ${jsonValue}' is invalid, use '$expand: ${key}: $expand: ${jsonValue}' instead.`);
        }
        if (isArray(value)) {
            throw new Error(`'$expand: ${key}: [...]' is invalid, use '$expand: ${key}: {...}' instead.`);
        }
        if (key.endsWith('/$count')) {
            deprecated.countInExpand();
        }
        return handleOptions('$expand', value, key);
    });
    return expands;
};
const handleExpandArray = (expands) => {
    if (expands.length < 1) {
        throw new Error(`Expand arrays must have at least 1 elements, got: ${JSON.stringify(expands)}`);
    }
    return expands.map((expand) => {
        return buildExpand(expand);
    });
};
const buildExpand = (expand) => {
    if (isPrimitive(expand)) {
        return escapeResource(expand);
    }
    else if (isArray(expand)) {
        const expandStr = handleExpandArray(expand);
        return join(expandStr);
    }
    else if (isObject(expand)) {
        const expandStr = handleExpandObject(expand);
        return join(expandStr);
    }
    else {
        throw new Error(`Unknown type for expand '${typeof expand}'`);
    }
};
const getRetryAfterHeaderDelayMs = (getRetryAfterHeader, err) => {
    const retryAfterRaw = getRetryAfterHeader === null || getRetryAfterHeader === void 0 ? void 0 : getRetryAfterHeader(err);
    if (typeof retryAfterRaw !== 'string') {
        return;
    }
    // TODO: Add support for parsing and converting HTTP date format values to delay.
    const retryAfterSeconds = parseInt(retryAfterRaw, 10);
    if (!Number.isInteger(retryAfterSeconds) || retryAfterSeconds < 0) {
        return;
    }
    return retryAfterSeconds * 1000;
};
const validParams = [
    'apiPrefix',
    'passthrough',
    'passthroughByMethod',
    'retry',
];
class PinejsClientCore {
    // `backendParams` must be used by a backend for any additional parameters it may have.
    constructor(params) {
        this.apiPrefix = '/';
        this.passthrough = {};
        this.passthroughByMethod = {};
        this.retry = false;
        if (isString(params)) {
            params = { apiPrefix: params };
        }
        if (isObject(params)) {
            for (const validParam of validParams) {
                const value = params[validParam];
                if (value != null) {
                    this[validParam] = value;
                }
            }
        }
    }
    canRetryDefaultHandler(err) {
        const code = err === null || err === void 0 ? void 0 : err.statusCode;
        return code == null || code === 429 || (code >= 500 && code < 600);
    }
    callWithRetry(fnCall, retry) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g;
            // Explicitly passing retry as false disables retrying for this call.
            if (retry === false || (retry == null && this.retry === false)) {
                return yield fnCall();
            }
            const retryDefaultParameters = this.retry || {};
            const retryParameters = retry !== null && retry !== void 0 ? retry : {};
            const minDelayMs = (_a = retryParameters.minDelayMs) !== null && _a !== void 0 ? _a : retryDefaultParameters.minDelayMs;
            const maxDelayMs = (_b = retryParameters.maxDelayMs) !== null && _b !== void 0 ? _b : retryDefaultParameters.maxDelayMs;
            const maxAttempts = (_c = retryParameters.maxAttempts) !== null && _c !== void 0 ? _c : retryDefaultParameters.maxAttempts;
            if (minDelayMs == null || minDelayMs <= 0) {
                throw new Error(`pinejs-client minDelayMs must be a positive integer, got: '${minDelayMs}'`);
            }
            if (maxDelayMs == null || maxDelayMs <= 0) {
                throw new Error(`pinejs-client maxDelayMs must be a positive integer, got: '${maxDelayMs}'`);
            }
            if (maxAttempts == null || maxAttempts <= 0) {
                throw new Error(`pinejs-client maxAttempts be a positive integer, got: '${maxDelayMs}'`);
            }
            if (minDelayMs > maxDelayMs) {
                throw new Error('pinejs-client maxDelayMs must be greater than or equal to minDelayMs');
            }
            const onRetryHandler = (_d = retryParameters.onRetry) !== null && _d !== void 0 ? _d : retryDefaultParameters.onRetry;
            const getRetryAfterHeader = (_e = retryParameters.getRetryAfterHeader) !== null && _e !== void 0 ? _e : retryDefaultParameters.getRetryAfterHeader;
            let attempt = 1;
            const canRetryHandler = (_g = (_f = retryParameters.canRetry) !== null && _f !== void 0 ? _f : retryDefaultParameters.canRetry) !== null && _g !== void 0 ? _g : this.canRetryDefaultHandler;
            // eslint-disable-next-line no-constant-condition -- we handle retry logic/delaying within the loop
            while (true) {
                try {
                    return yield fnCall();
                }
                catch (err) {
                    if (attempt >= maxAttempts || !canRetryHandler(err)) {
                        throw err;
                    }
                    let delayMs = Math.min(Math.pow(2, (attempt - 1)) * minDelayMs, maxDelayMs);
                    // note that attempt is incremented before calling onRetryHandler because
                    // retries effectively begin with attempt number 2.
                    attempt++;
                    const retryAfterDelayMs = getRetryAfterHeaderDelayMs(getRetryAfterHeader, err);
                    if (retryAfterDelayMs != null && retryAfterDelayMs > delayMs) {
                        delayMs = retryAfterDelayMs;
                    }
                    onRetryHandler === null || onRetryHandler === void 0 ? void 0 : onRetryHandler(err, delayMs, attempt, maxAttempts);
                    yield new Promise((resolve) => {
                        setTimeout(resolve, delayMs);
                    });
                }
            }
        });
    }
    // `backendParams` must be used by a backend for any additional parameters it may have.
    clone(params, backendParams) {
        if (isString(params)) {
            params = { apiPrefix: params };
        }
        const cloneParams = {};
        for (const validParam of validParams) {
            if (this[validParam] != null) {
                cloneParams[validParam] =
                    this[validParam];
            }
            const paramValue = params === null || params === void 0 ? void 0 : params[validParam];
            if (paramValue != null) {
                cloneParams[validParam] = paramValue;
            }
        }
        let cloneBackendParams = {};
        if (isObject(this.backendParams)) {
            cloneBackendParams = Object.assign({}, this.backendParams);
        }
        if (isObject(backendParams)) {
            cloneBackendParams = Object.assign(Object.assign({}, cloneBackendParams), backendParams);
        }
        return new this.constructor(cloneParams, cloneBackendParams);
    }
    get(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (params.url != null) {
                deprecated.urlInGet();
            }
            const result = yield this.request(Object.assign(Object.assign({}, params), { method: 'GET' }));
            return this._transformGetResult(params, result);
        });
    }
    _transformGetResult(params, data) {
        if (!isObject(data)) {
            throw new Error(`Response was not a JSON object: '${typeof data}'`);
        }
        if (data.d == null) {
            throw new Error("Invalid response received, the 'd' property is missing.");
        }
        if (params.id != null) {
            // singular
            if (data.d.length > 1) {
                throw new Error('Returned multiple results when only one was expected.');
            }
            return data.d[0];
        }
        return data.d;
    }
    transformGetResult(params) {
        return (data) => this._transformGetResult(params, data);
    }
    subscribe(params) {
        if (isString(params)) {
            throw new Error('`subscribe(url)` is no longer supported, please use `subscribe({ url })` instead.');
        }
        const { pollInterval } = params;
        const requestFn = this.prepare(params);
        return new Poll(requestFn, pollInterval);
    }
    put(params) {
        if (params.url != null) {
            deprecated.urlInPut();
        }
        return this.request(Object.assign(Object.assign({}, params), { method: 'PUT' }));
    }
    patch(params) {
        if (params.url != null) {
            deprecated.urlInPatch();
        }
        return this.request(Object.assign(Object.assign({}, params), { method: 'PATCH' }));
    }
    post(params) {
        if (params.url != null) {
            deprecated.urlInPost();
        }
        return this.request(Object.assign(Object.assign({}, params), { method: 'POST' }));
    }
    delete(params) {
        if (params.url != null) {
            deprecated.urlInDelete();
        }
        params.method = 'DELETE';
        return this.request(Object.assign(Object.assign({}, params), { method: 'DELETE' }));
    }
    getOrCreate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if ('url' in params && params.url != null) {
                deprecated.urlInGetOrCreate();
            }
            const { id, body } = params, restParams = __rest(params, ["id", "body"]);
            if (params.resource.endsWith('/$count')) {
                throw new Error('getOrCreate does not support $count on resources');
            }
            if (body == null) {
                throw new Error('The body property is missing');
            }
            if (!isObject(id) || isDate(id) || Object.keys(id).length === 0) {
                throw new Error('The id property must be an object with the natural key of the model');
            }
            const result = yield this.get(Object.assign(Object.assign({}, restParams), { id }));
            if (result != null) {
                return result;
            }
            return (yield this.post(Object.assign(Object.assign({}, restParams), { body: Object.assign(Object.assign({}, id), body) })));
        });
    }
    upsert(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if ('url' in params && params.url != null) {
                deprecated.urlInUpsert();
            }
            const { id, body } = params, restParams = __rest(params, ["id", "body"]);
            if (!isObject(id)) {
                throw new Error('The id property must be an object');
            }
            const naturalKeyProps = Object.keys(params.id);
            if (naturalKeyProps.length === 0) {
                throw new Error('The id property must be an object with the natural key of the model');
            }
            if (body == null) {
                throw new Error('The body property is missing');
            }
            const postParams = Object.assign(Object.assign({}, restParams), { body: Object.assign(Object.assign({}, body), id) });
            try {
                return yield this.post(postParams);
            }
            catch (err) {
                const isUniqueKeyViolationResponse = err.statusCode === 409 && /unique/i.test(err.body);
                if (!isUniqueKeyViolationResponse) {
                    throw err;
                }
                const { options } = restParams;
                const $filter = (options === null || options === void 0 ? void 0 : options.$filter) == null ? id : { $and: [options.$filter, id] };
                const patchParams = Object.assign(Object.assign({}, restParams), { options: Object.assign(Object.assign({}, options), { $filter }), body });
                yield this.patch(patchParams);
            }
        });
    }
    prepare(params) {
        var _a;
        if (isString(params)) {
            throw new Error('`prepare(url)` is no longer supported, please use `prepare({ url })` instead.');
        }
        // precompile the URL string to improve performance
        const compiledUrl = (_a = params.url) !== null && _a !== void 0 ? _a : this.compile(params);
        const urlQueryParamsStr = !compiledUrl.includes('?') ? '?' : '&';
        if (params.method == null) {
            params.method = 'GET';
        }
        else {
            params.method = params.method.toUpperCase();
        }
        const { body: defaultBody, passthrough: defaultPassthrough } = params;
        return (parameterAliases, body, passthrough) => __awaiter(this, void 0, void 0, function* () {
            if (body != null) {
                params.body = Object.assign(Object.assign({}, defaultBody), body);
            }
            else if (defaultBody != null) {
                params.body = Object.assign({}, defaultBody);
            }
            if (passthrough != null) {
                params.passthrough = Object.assign(Object.assign({}, defaultPassthrough), passthrough);
            }
            else if (defaultPassthrough != null) {
                params.passthrough = Object.assign({}, defaultPassthrough);
            }
            if (parameterAliases != null) {
                params.url =
                    compiledUrl +
                        urlQueryParamsStr +
                        mapObj(parameterAliases, (value, option) => {
                            if (!isPrimitive(value)) {
                                throw new Error(`Unknown type for parameter alias option '${option}': ${typeof value}`);
                            }
                            return `@${option}=${escapeValue(value)}`;
                        }).join('&');
            }
            else {
                params.url = compiledUrl;
            }
            const result = yield this.request(params);
            if (params.method === 'GET') {
                return this._transformGetResult(params, result);
            }
            return result;
        });
    }
    compile(params) {
        if (isString(params)) {
            throw new Error('Params must be an object not a string');
        }
        if (params.url != null) {
            deprecated.urlInCompile();
            return params.url;
        }
        else {
            if (params.resource == null) {
                throw new Error('Either the url or resource must be specified.');
            }
            if (params.resource.endsWith('/$count')) {
                deprecated.countInResource();
            }
            let url = escapeResource(params.resource);
            let { options } = params;
            if (options != null &&
                Object.prototype.hasOwnProperty.call(options, '$count')) {
                const keys = Object.keys(options);
                if (keys.length > 1) {
                    throw new Error(`When using '$expand: a: $count: ...' you can only specify $count, got: '${JSON.stringify(keys)}'`);
                }
                url += '/$count';
                options = options.$count;
            }
            if (Object.prototype.hasOwnProperty.call(params, 'id')) {
                const { id } = params;
                if (id == null) {
                    throw new Error('If the id property is set it must be non-null');
                }
                let value;
                if (isObject(id) && !isDate(id)) {
                    if ('@' in id) {
                        value = escapeParameterAlias(id['@']);
                    }
                    else {
                        value = mapObj(id, (v, k) => {
                            const escapedValue = isObject(v) && '@' in v
                                ? escapeParameterAlias(v['@'])
                                : escapeValue(v);
                            return `${k}=${escapedValue}`;
                        }).join(',');
                    }
                }
                else {
                    value = '' + escapeValue(id);
                }
                url += `(${value})`;
            }
            let queryOptions = [];
            if (options != null) {
                queryOptions = mapObj(options, (value, option) => {
                    if (option.startsWith('$') && !isValidOption(option)) {
                        throw new Error(`Unknown odata option '${option}'`);
                    }
                    return buildOption(option, value);
                });
            }
            if (params.customOptions != null) {
                throw new Error('`customOptions` has been removed, use `options` instead.');
            }
            if (queryOptions.length > 0) {
                url += '?' + queryOptions.join('&');
            }
            return url;
        }
    }
    request(params, overrides) {
        var _a, _b;
        if (overrides !== undefined) {
            throw new Error('request(params, overrides)` is unsupported, please use `request({ ...params, ...overrides })` instead.');
        }
        if (isString(params)) {
            throw new Error('`request(url)` is no longer supported, please use `request({ url })` instead.');
        }
        let { method, apiPrefix } = params;
        const { body, passthrough = {}, retry } = params;
        apiPrefix = apiPrefix !== null && apiPrefix !== void 0 ? apiPrefix : this.apiPrefix;
        const url = apiPrefix + ((_a = params.url) !== null && _a !== void 0 ? _a : this.compile(params));
        method = method !== null && method !== void 0 ? method : 'GET';
        method = method.toUpperCase();
        // Filter to prevent accidental parameter passthrough.
        const opts = Object.assign(Object.assign(Object.assign(Object.assign({}, this.passthrough), ((_b = this.passthroughByMethod[method]) !== null && _b !== void 0 ? _b : {})), passthrough), { url,
            body,
            method });
        // Do not await this._request result, so that we can preserve
        // the potentially enhanced promise-like result.
        return this.callWithRetry(() => this._request(opts), retry);
    }
}
exports.PinejsClientCore = PinejsClientCore;
//# sourceMappingURL=index.js.map