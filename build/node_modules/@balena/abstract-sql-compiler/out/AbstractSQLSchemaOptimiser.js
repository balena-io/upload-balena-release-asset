"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizeSchema = exports.generateRuleSlug = exports.Engines = void 0;
var Engines;
(function (Engines) {
    Engines["postgres"] = "postgres";
    Engines["mysql"] = "mysql";
    Engines["websql"] = "websql";
})(Engines || (exports.Engines = Engines = {}));
const AbstractSQLOptimiser_1 = require("./AbstractSQLOptimiser");
const sbvr_types_1 = require("@balena/sbvr-types");
const _ = require("lodash");
const AbstractSQLCompiler_1 = require("./AbstractSQLCompiler");
const countFroms = (n) => {
    let count = 0;
    n.forEach((p) => {
        if (Array.isArray(p)) {
            if ((0, AbstractSQLCompiler_1.isFromNode)(p)) {
                count++;
            }
            else {
                count += countFroms(p);
            }
        }
    });
    return count;
};
const generateRuleSlug = (tableName, ruleBody) => {
    const sha = sbvr_types_1.default.SHA.validateSync(`${tableName}$${JSON.stringify(ruleBody)}`).replace(/^\$sha256\$/, '');
    return `${tableName.slice(0, 30)}$${sha}`.slice(0, 63);
};
exports.generateRuleSlug = generateRuleSlug;
const optimizeSchema = (abstractSqlModel, createCheckConstraints = true) => {
    abstractSqlModel.rules = abstractSqlModel.rules
        .map((rule) => {
        const ruleBodyNode = rule.find((r) => r[0] === 'Body');
        if (ruleBodyNode == null || typeof ruleBodyNode === 'string') {
            throw new Error('Invalid rule');
        }
        let ruleBody = ruleBodyNode[1];
        if (typeof ruleBody === 'string') {
            throw new Error('Invalid rule');
        }
        const ruleSENode = rule.find((r) => r[0] === 'StructuredEnglish');
        if (ruleSENode == null) {
            throw new Error('Invalid structured English');
        }
        const ruleSE = ruleSENode[1];
        if (typeof ruleSE !== 'string') {
            throw new Error('Invalid structured English');
        }
        ruleBodyNode[1] = ruleBody = (0, AbstractSQLOptimiser_1.AbstractSQLOptimiser)(ruleBody, true);
        const count = countFroms(ruleBody);
        if (createCheckConstraints &&
            count === 1 &&
            (ruleBody[0] === 'NotExists' ||
                (ruleBody[0] === 'Equals' &&
                    _.isEqual(ruleBody[2], ['Number', 0]))) &&
            (0, AbstractSQLCompiler_1.isSelectQueryNode)(ruleBody[1])) {
            const selectQueryNodes = ruleBody[1].slice(1);
            if (selectQueryNodes.every((n) => ['Select', 'From', 'Where'].includes(n[0]))) {
                let fromNode = selectQueryNodes.find(AbstractSQLCompiler_1.isFromNode)[1];
                if (fromNode[0] === 'Alias') {
                    fromNode = fromNode[1];
                }
                if (fromNode[0] === 'Table') {
                    const whereNodes = selectQueryNodes.filter((n) => n[0] === 'Where');
                    let whereNode;
                    if (whereNodes.length > 1) {
                        whereNode = ['And', ...whereNodes.map((n) => n[1])];
                    }
                    else {
                        whereNode = whereNodes[0][1];
                    }
                    whereNode = ['Not', whereNode];
                    const convertReferencedFieldsToFields = (n) => {
                        n.forEach((p, i) => {
                            if (Array.isArray(p)) {
                                if (p[0] === 'ReferencedField') {
                                    n[i] = ['Field', p[2]];
                                }
                                else {
                                    convertReferencedFieldsToFields(p);
                                }
                            }
                        });
                    };
                    convertReferencedFieldsToFields(whereNode);
                    const tableName = fromNode[1];
                    const table = _.find(abstractSqlModel.tables, (t) => t.name === tableName);
                    if (table) {
                        table.checks ??= [];
                        table.checks.push({
                            description: ruleSE,
                            name: (0, exports.generateRuleSlug)(tableName, ruleBody),
                            abstractSql: whereNode,
                        });
                        return;
                    }
                }
            }
        }
        return rule;
    })
        .filter((v) => v != null);
    return abstractSqlModel;
};
exports.optimizeSchema = optimizeSchema;
//# sourceMappingURL=AbstractSQLSchemaOptimiser.js.map