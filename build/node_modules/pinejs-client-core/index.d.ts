import type { PickDeferred, Expanded, Resource } from '@balena/abstract-sql-to-typescript';
export type { Resource };
type ResourceName = `${Letter | Digit}${string}`;
export type AnyResourceObject = {
    [key: ResourceName]: any;
};
export type AnyResource = {
    Read: AnyObject;
    Write: AnyObject;
};
type StringKeyOf<T> = keyof T & string;
export type ExpandableStringKeyOf<T extends Resource['Read']> = StringKeyOf<ResourceExpand<T>>;
type ExtractExpand<T extends Resource['Read'], U extends keyof T> = NonNullable<Extract<T[U], ReadonlyArray<Resource['Read']>>[number]>;
type SelectPropsOf<T extends Resource['Read'], U extends ODataOptions<T>> = U['$select'] extends ReadonlyArray<StringKeyOf<T>> ? U['$select'][number] : U['$select'] extends StringKeyOf<T> ? U['$select'] : Exclude<StringKeyOf<T>, ExpandPropsOf<T, U>>;
type ExpandPropsOf<T extends Resource['Read'], U extends ODataOptions<T>> = U['$expand'] extends {
    [key in StringKeyOf<T>]?: any;
} ? StringKeyOf<U['$expand']> : U['$expand'] extends ReadonlyArray<StringKeyOf<T>> ? U['$expand'][number] : never;
type ExpandToResponse<T extends Resource['Read'], U extends ODataOptions<T>> = U['$expand'] extends {
    [key in StringKeyOf<T>]?: any;
} ? {
    [P in keyof U['$expand']]-?: OptionsToResponse<Expanded<T[P & string]>[number], U['$expand'][P], undefined>;
} : U['$expand'] extends ReadonlyArray<StringKeyOf<T>> ? {
    [P in U['$expand'][number]]-?: Array<PickDeferred<Expanded<T[P]>[number]>>;
} : {};
type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;
export type OptionsToResponse<T extends Resource['Read'], U extends ODataOptions<T>, ID extends ResourceId<T> | undefined> = U extends {
    $count: ODataOptions<T>['$count'];
} ? number : Equals<ID, any> extends true ? (PickDeferred<T, SelectPropsOf<T, U>> & ExpandToResponse<T, U>) | undefined : ID extends ResourceId<T> ? (PickDeferred<T, SelectPropsOf<T, U>> & ExpandToResponse<T, U>) | undefined : Array<PickDeferred<T, SelectPropsOf<T, U>> & ExpandToResponse<T, U>>;
export interface Dictionary<T> {
    [index: string]: T;
}
type LowerLetter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z';
type UpperLetter = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z';
type Letter = LowerLetter | UpperLetter;
type Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
interface PollOnObj {
    unsubscribe: () => void;
}
declare class Poll<T extends PromiseResultTypes> {
    private intervalTime;
    private subscribers;
    private stopped;
    private pollInterval?;
    private requestFn;
    constructor(requestFn: () => Promise<T>, intervalTime?: number);
    setPollInterval(intervalTime: number): void;
    runRequest(): Promise<void>;
    on(name: 'data', fn: (response: T) => void): PollOnObj;
    on(name: 'error', fn: (err: any) => void): PollOnObj;
    start(): void;
    stop(): void;
    destroy(): void;
    private restartTimeout;
}
declare const validParams: readonly ["apiPrefix", "passthrough", "passthroughByMethod", "retry"];
export type PreparedFn<T extends Dictionary<ParameterAlias>, U, TResource extends Resource = AnyResource> = (parameterAliases?: T, body?: Params<TResource>['body'], passthrough?: Params<TResource>['passthrough']) => U;
export type RetryParametersObj = {
    canRetry?: (err: any) => boolean;
    onRetry?: (prevErr: any, delayMs: number, attempt: number, maxAttempts: number) => void;
    getRetryAfterHeader?: (err: unknown) => string | undefined;
    minDelayMs?: number;
    maxDelayMs?: number;
    maxAttempts?: number;
};
export type RetryParameters = RetryParametersObj | false;
export declare abstract class PinejsClientCore<
/** @deprecated This was for the purposes of `clone` and we now use `this` for that */
PinejsClient = unknown, Model extends {
    [key in keyof Model]: Resource;
} = {
    [key in string]: AnyResource;
}> {
    apiPrefix: string;
    passthrough: AnyObject;
    passthroughByMethod: AnyObject;
    backendParams?: AnyObject;
    retry: RetryParameters;
    constructor(params: string | ConstructorParams);
    private canRetryDefaultHandler;
    protected callWithRetry<T>(fnCall: () => Promise<T>, retry?: RetryParameters): Promise<T>;
    clone(params: string | ConstructorParams, backendParams?: AnyObject): this;
    get<TResource extends StringKeyOf<Model>, TParams extends Params<Model[TResource]> & {
        resource: TResource;
    }>(params: {
        resource: TResource;
    } & TParams): Promise<NoInfer<OptionsToResponse<Model[TResource]['Read'], NonNullable<TParams['options']>, TParams['id']>>>;
    /**
     * @deprecated GETing via `url` is deprecated
     */
    get<T extends Resource = AnyResource>(params: {
        resource?: undefined;
        url: NonNullable<Params<T>['url']>;
    } & Params<T>): Promise<PromiseResultTypes>;
    protected _transformGetResult<T extends Resource>(params: Params<T> & {
        options: {
            $count: NonNullable<ODataOptions<T['Read']>['$count']>;
        };
    }, data: AnyObject): number;
    protected _transformGetResult<T extends Resource>(params: Params<T> & {
        id: NonNullable<Params<T>['id']>;
    }, data: AnyObject): AnyObject | undefined;
    protected _transformGetResult<T extends Resource>(params: Omit<Params<T>, 'id'>, data: AnyObject): AnyObject[];
    /** @deprecated */
    protected transformGetResult<T extends Resource>(params: Params<T> & {
        options: {
            $count: NonNullable<ODataOptions<T['Read']>['$count']>;
        };
    }): (data: AnyObject) => number;
    protected transformGetResult<T extends Resource>(params: Params<T> & {
        id: NonNullable<Params<T>['id']>;
    }): (data: AnyObject) => AnyObject | undefined;
    protected transformGetResult<T extends Resource>(params: Omit<Params<T>, 'id'>): (data: AnyObject) => AnyObject[];
    subscribe<TResource extends StringKeyOf<Model>, TParams extends SubscribeParams<Model[TResource]> & {
        resource: TResource;
    }>(params: TParams & {
        resource: TResource;
    }): Poll<NoInfer<OptionsToResponse<Model[TResource]['Read'], NonNullable<TParams['options']>, TParams['id']>>>;
    put<TResource extends StringKeyOf<Model>>(params: {
        resource: TResource;
        url?: undefined;
    } & Params<Model[TResource]>): Promise<void>;
    /**
     * @deprecated PUTing via `url` is deprecated
     */
    put<T extends Resource = AnyResource>(params: {
        resource?: undefined;
        url: NonNullable<Params<T>['url']>;
    } & Params<T>): Promise<void>;
    patch<TResource extends StringKeyOf<Model>>(params: {
        resource: TResource;
        url?: undefined;
    } & Params<Model[TResource]>): Promise<void>;
    /**
     * @deprecated PATCHing via `url` is deprecated
     */
    patch<T extends Resource = AnyResource>(params: {
        resource?: undefined;
        url: NonNullable<Params<T>['url']>;
    } & Params<T>): Promise<void>;
    post<TResource extends StringKeyOf<Model>>(params: {
        resource: TResource;
    } & Params<Model[TResource]>): Promise<PickDeferred<Model[TResource]['Read']>>;
    /**
     * @deprecated POSTing via `url` is deprecated
     */
    post<T extends Resource = AnyResource>(params: {
        resource?: undefined;
        url: NonNullable<Params<T>['url']>;
    } & Params<T>): Promise<AnyObject>;
    delete<TResource extends StringKeyOf<Model>>(params: {
        resource: TResource;
    } & Params<Model[TResource]>): Promise<void>;
    /**
     * @deprecated DELETEing via `url` is deprecated
     */
    delete<T extends Resource = AnyResource>(params: {
        resource?: undefined;
        url: NonNullable<Params<T>['url']>;
    } & Params<T>): Promise<void>;
    getOrCreate<TResource extends StringKeyOf<Model>, TParams extends GetOrCreateParams<Model[TResource]> & {
        resource: TResource;
    }>(params: {
        resource: TResource;
    } & TParams): Promise<NoInfer<OptionsToResponse<Model[TResource]['Read'], NonNullable<TParams['options']>, TParams['id']>>>;
    upsert<TResource extends StringKeyOf<Model>>(params: {
        resource: TResource;
        url?: undefined;
    } & UpsertParams<Model[TResource]>): Promise<undefined | PickDeferred<Model[TResource]['Read']>>;
    prepare<TAliases extends Dictionary<Array<'null' | 'string' | 'number' | 'boolean' | 'Date'>>, TResource extends StringKeyOf<Model>, TParams extends Params<Model[TResource]> & {
        resource: TResource;
    }>(params: {
        resource: TResource;
        method?: 'GET';
    } & TParams, 
    /**
     * If this is passed then all the listed aliases are expected to be used in params and passed to the returned prepared function.
     */
    expectedAliases: TAliases): PreparedFn<StringDictionaryToDictType<TAliases>, Promise<NoInfer<OptionsToResponse<Model[TResource]['Read'], NonNullable<TParams['options']>, TParams['id']>>>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>, TResource extends StringKeyOf<Model>, TParams extends Params<Model[TResource]> & {
        resource: TResource;
    }>(params: {
        resource: TResource;
        method?: 'GET';
    } & TParams): PreparedFn<T, Promise<NoInfer<OptionsToResponse<Model[TResource]['Read'], NonNullable<TParams['options']>, TParams['id']>>>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>, TResource extends StringKeyOf<Model>>(params: Params<Model[TResource]> & {
        resource: TResource;
        method?: 'GET';
        options: {
            $count: NonNullable<ODataOptions<Model[TResource]['Read']>['$count']>;
        };
    }): PreparedFn<T, Promise<number>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>>(params: Params & {
        method?: 'GET';
        options: {
            $count: NonNullable<ODataOptions<AnyResource['Read']>['$count']>;
        };
    }): PreparedFn<T, Promise<number>>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>, TResource extends StringKeyOf<Model>>(params: Params<Model[TResource]> & {
        resource: TResource;
        method?: 'GET';
        id: NonNullable<Params<Model[TResource]>['id']>;
    }): PreparedFn<T, Promise<AnyObject | undefined>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>>(params: Params & {
        method?: 'GET';
        id: NonNullable<Params['id']>;
    }): PreparedFn<T, Promise<AnyObject | undefined>>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>, TResource extends StringKeyOf<Model>>(params: Omit<Params<Model[TResource]>, 'id'> & {
        resource: TResource;
        method?: 'GET';
    }): PreparedFn<T, Promise<AnyObject[]>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>>(params: Omit<Params, 'id'> & {
        method?: 'GET';
    }): PreparedFn<T, Promise<AnyObject[]>>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>, TResource extends StringKeyOf<Model>>(params: Params<Model[TResource]> & {
        resource: TResource;
        method?: 'GET';
    }): PreparedFn<T, Promise<PromiseResultTypes>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>>(params: Params & {
        method?: 'GET';
    }): PreparedFn<T, Promise<PromiseResultTypes>>;
    prepare<TAliases extends Dictionary<Array<'null' | 'string' | 'number' | 'boolean' | 'Date'>>, TResource extends StringKeyOf<Model>>(params: Params<Model[TResource]> & {
        resource: TResource;
        method: 'PUT' | 'PATCH' | 'DELETE';
    }, 
    /**
     * If this is passed then all the listed aliases are expected to be used in params and passed to the returned prepared function.
     */
    expectedAliases: TAliases): PreparedFn<StringDictionaryToDictType<TAliases>, Promise<undefined>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>, TResource extends StringKeyOf<Model>>(params: Params<Model[TResource]> & {
        resource: TResource;
        method: 'PUT' | 'PATCH' | 'DELETE';
    }): PreparedFn<T, Promise<undefined>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>>(params: Params & {
        method: 'PUT' | 'PATCH' | 'DELETE';
    }): PreparedFn<T, Promise<undefined>>;
    prepare<TAliases extends Dictionary<Array<'null' | 'string' | 'number' | 'boolean' | 'Date'>>, TResource extends StringKeyOf<Model>>(params: Params<Model[TResource]> & {
        resource: TResource;
        method: 'POST';
    }, 
    /**
     * If this is passed then all the listed aliases are expected to be used in params and passed to the returned prepared function.
     */
    expectedAliases: TAliases): PreparedFn<StringDictionaryToDictType<TAliases>, Promise<AnyObject>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>, TResource extends StringKeyOf<Model>>(params: Params<Model[TResource]> & {
        resource: TResource;
        method: 'POST';
    }): PreparedFn<T, Promise<AnyObject>, Model[TResource]>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>>(params: Params & {
        method: 'POST';
    }): PreparedFn<T, Promise<AnyObject>>;
    /**
     * @deprecated Please pass the parameter aliases as a parameter to `prepare` instead to allow for inference and future runtime checks
     */
    prepare<T extends Dictionary<ParameterAlias>>(params: Params & {
        resource?: undefined;
        method: 'POST';
    }): PreparedFn<T, Promise<AnyObject>>;
    compile<TResource extends StringKeyOf<Model>>(params: {
        resource: TResource;
    } & Params<Model[TResource]>): string;
    /**
     * @deprecated Compiling a `url` is deprecated, it's a noop so you can just use the url directly
     */
    compile<T extends Resource = AnyResource>(params: {
        resource?: undefined;
        url: NonNullable<Params<T>['url']>;
    } & Params<T>): string;
    compile(params: Params): string;
    request<T extends Resource>(params: Params<T> & {
        method?: 'GET';
        options: {
            $count: NonNullable<ODataOptions<T['Read']>['$count']>;
        };
    }): Promise<{
        d: number;
    }>;
    request<T extends Resource>(params: Params<T> & {
        method?: 'GET';
        id: NonNullable<Params<T>['id']>;
    }): Promise<{
        d: AnyObject | undefined;
    }>;
    request<T extends Resource>(params: Omit<Params<T>, 'id'> & {
        method?: 'GET';
    }): Promise<{
        d: AnyObject[];
    }>;
    request<T extends Resource>(params: Params<T> & {
        method?: 'GET';
    }): Promise<{
        d: PromiseResultTypes;
    }>;
    request<T extends Resource>(params: Params<T> & {
        method: 'PUT' | 'PATCH' | 'DELETE';
    }): Promise<undefined>;
    request<T extends Resource>(params: Params<T> & {
        method: 'POST';
    }): Promise<AnyObject>;
    request<T extends Resource>(params: Params<T>, overrides?: undefined): Promise<PromiseResultTypes | undefined>;
    abstract _request(params: {
        method: string;
        url: string;
        body?: AnyObject;
    } & AnyObject): Promise<NonNullable<unknown>>;
}
export type PromiseResultTypes = number | AnyObject | AnyObject[] | undefined;
type FilterOperationValue<T extends Resource['Read']> = Filter<T>;
type FilterFunctionValue<T extends Resource['Read']> = Filter<T>;
type DurationValue = {
    negative?: boolean;
    days?: number;
    hours?: number;
    minutes?: number;
    seconds?: number;
};
export type NestedFilterOperations<T extends Resource['Read'], NestedKey extends StringKeyOf<T> = ExpandableStringKeyOf<T>> = {
    $count?: NestedKey extends ExpandableStringKeyOf<T> ? Filter<ExtractExpand<T, NestedKey>> | ODataCountOptions<ExtractExpand<T, NestedKey>> : never;
    $in?: Filter<T>;
    $any?: NestedKey extends ExpandableStringKeyOf<T> ? Lambda<ExtractExpand<T, NestedKey>> : never;
    $all?: NestedKey extends ExpandableStringKeyOf<T> ? Lambda<ExtractExpand<T, NestedKey>> : never;
};
type FilterOperations<T extends Resource['Read']> = {
    '@'?: string;
    $raw?: RawFilter<T>;
    $?: string | string[];
    $and?: Filter<T>;
    $or?: Filter<T>;
    $not?: Filter<T>;
    $ne?: FilterOperationValue<T>;
    $eq?: FilterOperationValue<T>;
    $gt?: FilterOperationValue<T>;
    $ge?: FilterOperationValue<T>;
    $lt?: FilterOperationValue<T>;
    $le?: FilterOperationValue<T>;
    $add?: FilterOperationValue<T>;
    $sub?: FilterOperationValue<T>;
    $mul?: FilterOperationValue<T>;
    $div?: FilterOperationValue<T>;
    $mod?: FilterOperationValue<T>;
    $contains?: FilterFunctionValue<T>;
    $endswith?: FilterFunctionValue<T>;
    $startswith?: FilterFunctionValue<T>;
    $length?: FilterFunctionValue<T>;
    $indexof?: FilterFunctionValue<T>;
    $substring?: FilterFunctionValue<T>;
    $tolower?: FilterFunctionValue<T>;
    $toupper?: FilterFunctionValue<T>;
    $trim?: FilterFunctionValue<T>;
    $concat?: FilterFunctionValue<T>;
    $year?: FilterFunctionValue<T>;
    $month?: FilterFunctionValue<T>;
    $day?: FilterFunctionValue<T>;
    $hour?: FilterFunctionValue<T>;
    $minute?: FilterFunctionValue<T>;
    $second?: FilterFunctionValue<T>;
    $fractionalseconds?: FilterFunctionValue<T>;
    $date?: FilterFunctionValue<T>;
    $time?: FilterFunctionValue<T>;
    $totaloffsetminutes?: FilterFunctionValue<T>;
    $now?: FilterFunctionValue<T>;
    $duration?: DurationValue;
    $maxdatetime?: FilterFunctionValue<T>;
    $mindatetime?: FilterFunctionValue<T>;
    $totalseconds?: FilterFunctionValue<T>;
    $round?: FilterFunctionValue<T>;
    $floor?: FilterFunctionValue<T>;
    $ceiling?: FilterFunctionValue<T>;
    $isof?: FilterFunctionValue<T>;
    $cast?: FilterFunctionValue<T>;
};
export type FilterObj<T extends Resource['Read'] = AnyResourceObject> = {
    [key in StringKeyOf<T>]?: Filter<T> | NestedFilterOperations<T, key> | undefined;
} & FilterOperations<T>;
export type FilterArray<T extends Resource['Read'] = AnyResourceObject> = ReadonlyArray<Filter<T>>;
export type FilterBaseType = string | number | null | boolean | Date;
export type RawFilter<T extends Resource['Read'] = AnyResourceObject> = string | [string, ...Array<Filter<T>>] | {
    $string: string;
    [index: ResourceName]: Filter<T>;
};
export interface Lambda<T extends Resource['Read'] = AnyResourceObject, Alias extends string = string> {
    $alias: Alias;
    $expr: Filter<T & {
        [a in NoInfer<Alias>]: T;
    }>;
}
export type Filter<T extends Resource['Read'] = AnyResourceObject> = FilterObj<T> | FilterArray<T> | FilterBaseType;
export type ResourceExpand<T extends Resource['Read'] = AnyResourceObject> = {
    [resource in StringKeyOf<T> as ExtractExpand<T, resource> extends never ? never : resource]?: ODataOptions<ExtractExpand<T, resource>>;
};
export type BaseExpand<T extends Resource['Read'] = AnyResourceObject> = ExpandableStringKeyOf<T> | ResourceExpand<T>;
export type Expand<T extends Resource['Read'] = AnyResourceObject> = BaseExpand<T> | ReadonlyArray<BaseExpand<T>>;
/**
 * This can interact poorly with generics because `field: 'desc'` would be treated as `field: string` which doesn't match
 */
type OrderByDirection = 'asc' | 'desc';
export type OrderBy<T extends Resource['Read'] = AnyResourceObject> = StringKeyOf<T> | ReadonlyArray<OrderBy<T>> | {
    [k in StringKeyOf<T>]?: OrderByDirection;
} | ({
    [k in ExpandableStringKeyOf<T> & ResourceName]?: {
        $count: ODataCountOptions<ExtractExpand<T, k>>;
    };
} & {
    $dir: OrderByDirection;
});
type StringPrimitiveToType<T extends 'null' | 'string' | 'number' | 'boolean' | 'Date'> = ('null' extends T ? null : never) | ('number' extends T ? number : never) | ('string' extends T ? string : never) | ('boolean' extends T ? boolean : never) | ('Date' extends T ? Date : never);
type StringDictionaryToDictType<T extends Dictionary<Array<'null' | 'string' | 'number' | 'boolean' | 'Date'>>> = keyof T extends never ? Record<string, never> : {
    [key in keyof T]: StringPrimitiveToType<T[key][number]>;
};
export type Primitive = null | string | number | boolean | Date;
export type ParameterAlias = Primitive;
export interface ODataOptionsWithoutCount<T extends Resource['Read'] = AnyResourceObject> {
    $filter?: Filter<T>;
    $expand?: Expand<T>;
    $orderby?: OrderBy<T>;
    $top?: number;
    $skip?: number;
    $select?: StringKeyOf<T> | ReadonlyArray<StringKeyOf<T>>;
    $format?: string;
    [index: string]: undefined | ParameterAlias | string[] | Filter<T> | Expand<T> | OrderBy<T>;
}
export type ODataCountOptions<T extends Resource['Read'] = AnyResourceObject> = Pick<ODataOptionsWithoutCount<T>, '$filter'>;
export interface ODataOptions<T extends Resource['Read'] = AnyResourceObject> extends ODataOptionsWithoutCount<NoInfer<T>> {
    $count?: ODataCountOptions<NoInfer<T>>;
    [index: string]: ODataOptionsWithoutCount<NoInfer<T>>[string] | ODataCountOptions<NoInfer<T>>;
}
export type OptionsObject<T extends Resource['Read'] = AnyResourceObject> = ODataOptions<T>;
export type ODataMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
type BaseResourceId = string | number | Date | {
    '@': string;
};
type ResourceAlternateKey<T extends Resource['Read']> = {
    [key in StringKeyOf<T>]?: BaseResourceId;
};
type ResourceId<T extends Resource['Read']> = BaseResourceId | ResourceAlternateKey<T>;
export type AnyObject = Dictionary<any>;
export interface Params<T extends Resource = AnyResource> {
    apiPrefix?: string;
    method?: ODataMethod;
    resource?: string;
    id?: ResourceId<T['Read']>;
    url?: string;
    body?: Partial<T['Write']>;
    passthrough?: AnyObject;
    passthroughByMethod?: {
        [method in ODataMethod]?: AnyObject;
    };
    options?: ODataOptions<T['Read']>;
    retry?: RetryParameters;
}
export type ConstructorParams = Pick<Params, (typeof validParams)[number]>;
export interface SubscribeParams<T extends Resource = AnyResource> extends Params<T> {
    method?: 'GET';
    pollInterval?: number;
}
export interface GetOrCreateParams<T extends Resource = AnyResource> extends Omit<Params<T>, 'method' | 'url'> {
    id: ResourceAlternateKey<T['Read']>;
    resource: string;
    body: Partial<T['Write']>;
}
export interface UpsertParams<T extends Resource = AnyResource> extends Omit<Params<T>, 'id' | 'method' | 'url'> {
    id: {
        [key in StringKeyOf<T['Write']>]?: Primitive;
    };
    resource: string;
    body: Partial<T['Write']>;
}
