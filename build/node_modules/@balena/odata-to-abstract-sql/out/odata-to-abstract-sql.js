"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OData2AbstractSQL = exports.isBindReference = exports.rewriteBinds = exports.odataNameToSqlName = exports.sqlNameToODataName = void 0;
const _ = require("lodash");
const memoize = require("memoizee");
const stringHash = require("string-hash");
const abstract_sql_compiler_1 = require("@balena/abstract-sql-compiler");
const convertToModernDefinition = (definition) => {
    if ('abstractSql' in definition) {
        return definition;
    }
    return {
        binds: definition.extraBinds,
        abstractSql: definition.abstractSqlQuery,
    };
};
const comparison = {
    eq: 'IsNotDistinctFrom',
    ne: 'IsDistinctFrom',
    gt: 'GreaterThan',
    ge: 'GreaterThanOrEqual',
    lt: 'LessThan',
    le: 'LessThanOrEqual',
};
const operations = {
    add: 'Add',
    sub: 'Subtract',
    mul: 'Multiply',
    div: 'Divide',
};
const rewriteComputed = (computed, tableName, tableAlias) => {
    const rewrittenComputed = _.cloneDeep(computed);
    modifyAbstractSql('ReferencedField', rewrittenComputed, (referencedField) => {
        if (referencedField[1] === tableName) {
            referencedField[1] = tableAlias;
        }
    });
    return rewrittenComputed;
};
const containsQueryOption = (opts) => {
    if (opts == null) {
        return false;
    }
    for (const key in opts) {
        if (key.startsWith('$')) {
            return true;
        }
    }
    return false;
};
const addNestedFieldSelect = (selectNode, fromNode, fieldName, fieldNameAlias) => {
    let aliasName;
    let tableOrSubqueryNode;
    if ((0, abstract_sql_compiler_1.isAliasNode)(fromNode)) {
        tableOrSubqueryNode = fromNode[1];
        aliasName = fromNode[2];
    }
    else {
        tableOrSubqueryNode = fromNode;
    }
    if ((0, abstract_sql_compiler_1.isTableNode)(tableOrSubqueryNode)) {
        selectNode.push([
            'Alias',
            ['ReferencedField', aliasName ?? tableOrSubqueryNode[1], fieldName],
            fieldNameAlias,
        ]);
        return;
    }
    if (!(0, abstract_sql_compiler_1.isSelectQueryNode)(tableOrSubqueryNode)) {
        throw new Error(`Adding a nested field select to a subquery containing a ${tableOrSubqueryNode[0]} is not supported`);
    }
    if (aliasName == null) {
        throw new Error('Found unaliased SelectQueryNode');
    }
    const nestedSelectNode = tableOrSubqueryNode.find(abstract_sql_compiler_1.isSelectNode);
    if (nestedSelectNode == null) {
        throw new Error(`Cannot find SelectNode in subquery`);
    }
    const nestedFromNode = tableOrSubqueryNode.find(abstract_sql_compiler_1.isFromNode);
    if (nestedFromNode == null) {
        throw new Error(`Cannot find FromNode in subquery`);
    }
    addNestedFieldSelect(nestedSelectNode[1], nestedFromNode[1], fieldName, fieldNameAlias);
    selectNode.push(['ReferencedField', aliasName, fieldNameAlias]);
};
class Query {
    constructor() {
        this.select = [];
        this.from = [];
        this.where = [];
        this.extras = [];
    }
    merge(otherQuery) {
        this.select = this.select.concat(otherQuery.select);
        this.from = this.from.concat(otherQuery.from);
        this.where = this.where.concat(otherQuery.where);
        this.extras = this.extras.concat(otherQuery.extras);
    }
    fromResource(odataToAbstractSql, resource, args = odataToAbstractSql, bypassDefinition, isModifyOperation) {
        const tableRef = odataToAbstractSql.getTableReference(resource, args.extraBindVars, args.bindVarsLength, bypassDefinition, resource.tableAlias, isModifyOperation);
        this.from.push(tableRef);
    }
    addNestedFieldSelect(fieldName, fieldNameAlias) {
        if (this.from.length !== 1) {
            throw new Error(`Adding nested field SELECTs is only supported for queries with exactly 1 FROM clause. Found ${this.from.length}`);
        }
        addNestedFieldSelect(this.select, this.from[0], fieldName, fieldNameAlias);
    }
    compile(queryType) {
        const compiled = [];
        let where = this.where;
        if (queryType === 'SelectQuery') {
            compiled.push(['Select', this.select]);
        }
        this.from.forEach((tableName) => {
            compiled.push(['From', tableName]);
        });
        if (where.length > 0) {
            if (where.length > 1) {
                where = [['And', ...where]];
            }
            compiled.push(['Where', ...where]);
        }
        return [queryType, ...compiled, ...this.extras];
    }
}
exports.sqlNameToODataName = memoize((sqlName) => sqlName.replace(/-/g, '__').replace(/ /g, '_'), { primitive: true });
exports.odataNameToSqlName = memoize((odataName) => odataName.replace(/__/g, '-').replace(/_/g, ' '), { primitive: true });
const modifyAbstractSql = (match, abstractSql, fn) => {
    if (Array.isArray(abstractSql)) {
        if (abstractSql[0] === match) {
            fn(abstractSql);
        }
        else {
            abstractSql.forEach((abstractSqlComponent) => {
                modifyAbstractSql(match, abstractSqlComponent, fn);
            });
        }
    }
};
const rewriteBinds = (definition, existingBinds, inc = 0) => {
    const { binds } = definition;
    if (binds == null || binds.length === 0) {
        return;
    }
    inc += existingBinds.length;
    modifyAbstractSql('Bind', definition.abstractSql, (bind) => {
        if (typeof bind[1] === 'number') {
            bind[1] += inc;
        }
    });
    existingBinds.push(...binds);
};
exports.rewriteBinds = rewriteBinds;
const isBindReference = (maybeBind) => {
    return (maybeBind != null &&
        typeof maybeBind === 'object' &&
        'bind' in maybeBind &&
        (typeof maybeBind.bind === 'string' || typeof maybeBind.bind === 'number'));
};
exports.isBindReference = isBindReference;
const isDynamicResource = (resource, alreadyComputedFieldsLookup) => {
    return (resource.definition != null ||
        resource.fields.some((f) => f.computed != null &&
            !alreadyComputedFieldsLookup[resource.name + '$' + f.fieldName]));
};
const addBodyKey = (resourceName, fieldName, bind, bodyKeys, extraBodyVars) => {
    const qualifiedIDField = resourceName + '.' + fieldName;
    if (!bodyKeys.includes(qualifiedIDField) && !bodyKeys.includes(fieldName)) {
        bodyKeys.push(qualifiedIDField);
        extraBodyVars[qualifiedIDField] = bind;
    }
};
class OData2AbstractSQL {
    constructor(clientModel, methods = {}, { minimizeAliases = false } = {}) {
        this.clientModel = clientModel;
        this.methods = methods;
        this.extraBodyVars = {};
        this.extraBindVars = [];
        this.resourceAliases = {};
        this.bindVarsLength = 0;
        this.alreadyComputedFields = {};
        const MAX_ALIAS_LENGTH = 63;
        const shortAliases = generateShortAliases(clientModel);
        this.checkAlias = memoize((alias) => {
            let aliasLength = alias.length;
            if (minimizeAliases === false && aliasLength <= MAX_ALIAS_LENGTH) {
                return alias;
            }
            alias = _(alias)
                .split('.')
                .map((part) => {
                if (minimizeAliases === false && aliasLength <= MAX_ALIAS_LENGTH) {
                    return part;
                }
                aliasLength -= part.length;
                const shortAlias = _(part)
                    .split('-')
                    .map((part2) => {
                    part2 = _(part2)
                        .split(' ')
                        .map((part3) => {
                        const shortPart2 = shortAliases[part3];
                        if (shortPart2) {
                            return shortPart2;
                        }
                        return part3;
                    })
                        .join(' ');
                    const shortPart = shortAliases[part2];
                    if (shortPart) {
                        return shortPart;
                    }
                    return part2;
                })
                    .join('-');
                aliasLength += shortAlias.length;
                return shortAlias;
            })
                .join('.');
            if (aliasLength <= MAX_ALIAS_LENGTH) {
                return alias;
            }
            const hashStr = stringHash(alias).toString(36) + '$';
            return (hashStr + alias.slice(hashStr.length + alias.length - MAX_ALIAS_LENGTH));
        });
    }
    match(path, $method, bodyKeys, bindVarsLength, methods) {
        const method = $method === 'MERGE' ? 'PATCH' : $method;
        const savedMethods = this.methods;
        try {
            if (methods != null) {
                this.methods = methods;
            }
            this.reset();
            this.bindVarsLength = bindVarsLength;
            let tree;
            if (_.isEmpty(path)) {
                tree = ['$serviceroot'];
            }
            else if (['$metadata', '$serviceroot'].includes(path.resource)) {
                tree = [path.resource];
            }
            else {
                const query = this.PathSegment(method, bodyKeys, path);
                switch (method) {
                    case 'PUT': {
                        this.putReset();
                        const insertQuery = this.PathSegment('PUT-INSERT', bodyKeys, path);
                        tree = [
                            'UpsertQuery',
                            insertQuery.compile('InsertQuery'),
                            query.compile('UpdateQuery'),
                        ];
                        break;
                    }
                    case 'GET':
                        tree = query.compile('SelectQuery');
                        break;
                    case 'PATCH':
                        tree = query.compile('UpdateQuery');
                        break;
                    case 'POST':
                        tree = query.compile('InsertQuery');
                        break;
                    case 'DELETE':
                        tree = query.compile('DeleteQuery');
                        break;
                    default:
                        throw new SyntaxError(`Unknown method "${method}"`);
                }
            }
            return {
                tree,
                extraBodyVars: this.extraBodyVars,
                extraBindVars: this.extraBindVars,
            };
        }
        finally {
            this.methods = savedMethods;
        }
    }
    PathSegment(method, bodyKeys, path) {
        if (!path.resource) {
            throw new SyntaxError('Path segment must contain a resource');
        }
        const hasQueryOpts = containsQueryOption(path.options);
        const resource = this.Resource(path.resource, this.defaultResource);
        this.defaultResource = resource;
        const query = new Query();
        const bypassDefinition = method !== 'GET';
        query.fromResource(this, resource, this, bypassDefinition, bypassDefinition);
        const referencedIdField = [
            'ReferencedField',
            resource.tableAlias,
            resource.idField,
        ];
        const pathKeyWhere = this.PathKey(method, path, resource, bodyKeys);
        let addPathKey = true;
        if (hasQueryOpts && path.options?.$expand) {
            this.Expands(resource, query, path.options.$expand.properties);
        }
        let bindVars;
        if (path.property) {
            const childQuery = this.PathSegment(method, bodyKeys, path.property);
            query.merge(childQuery);
            if (!path.property.resource) {
                throw new SyntaxError('PathSegment has a property without a resource?');
            }
            const navigation = this.NavigateResources(resource, path.property.resource);
            query.where.push(navigation.where);
        }
        else if (path.link) {
            if (!path.link.resource) {
                throw new SyntaxError('PathSegment has a link without a resource?');
            }
            const linkResource = this.Resource(path.link.resource, resource);
            let aliasedField;
            let referencedField;
            if (this.FieldContainedIn(linkResource.resourceName, resource)) {
                referencedField = this.ReferencedField(resource, linkResource.resourceName);
                aliasedField = ['Alias', referencedField, linkResource.resourceName];
            }
            else if (this.FieldContainedIn(resource.resourceName, linkResource)) {
                referencedField = this.ReferencedField(linkResource, resource.resourceName);
                aliasedField = ['Alias', referencedField, resource.resourceName];
            }
            else {
                throw new Error('Cannot navigate links');
            }
            if (path.link.key != null) {
                if ((0, exports.isBindReference)(path.link.key)) {
                    query.where.push([
                        comparison.eq,
                        referencedField,
                        this.Bind(path.link.key),
                    ]);
                }
                else {
                    throw new SyntaxError('Cannot use named keys with $links');
                }
            }
            query.select.push(aliasedField);
        }
        else if (method === 'PUT' ||
            method === 'PUT-INSERT' ||
            method === 'POST' ||
            method === 'PATCH') {
            const resourceMapping = this.ResourceMapping(resource, true);
            bindVars = this.BindVars(method, bodyKeys, resource.resourceName, Object.entries(resourceMapping));
            if (bindVars.length === 0 && method === 'PATCH') {
                throw new SyntaxError('PATCH requests must update at least one field');
            }
            query.extras.push(['Fields', bindVars.map((b) => b[0])]);
            if ((hasQueryOpts ||
                isDynamicResource(resource, this.alreadyComputedFields) ||
                pathKeyWhere != null) &&
                (method === 'POST' || method === 'PUT-INSERT')) {
                const subQuery = new Query();
                subQuery.select = bindVars.map((bindVar) => [
                    'ReferencedField',
                    '$insert',
                    bindVar[0],
                ]);
                subQuery.from.push([
                    'Alias',
                    [
                        'SelectQuery',
                        [
                            'Select',
                            (resource.modifyFields ?? resource.fields)
                                .filter((field) => field.computed == null)
                                .map((field) => {
                                const alias = field.fieldName;
                                const bindVar = bindVars?.find((v) => v[0] === alias);
                                const value = bindVar?.[1] ?? ['Null'];
                                if (value === 'Default') {
                                    throw new Error('Cannot use default values for a filtered insert query');
                                }
                                return ['Alias', ['Cast', value, field.dataType], alias];
                            }),
                        ],
                    ],
                    '$insert',
                ]);
                const bindVarSelectQuery = [
                    'SelectQuery',
                    ['Select', [['ReferencedField', '$insert', '*']]],
                ];
                const unionResource = { ...resource };
                if (unionResource.definition == null ||
                    typeof unionResource.definition !== 'object') {
                    unionResource.definition = {
                        binds: [],
                        abstractSql: bindVarSelectQuery,
                    };
                }
                else {
                    const rewrittenBindVars = [];
                    const definition = (unionResource.definition =
                        this.rewriteDefinition(unionResource.definition, rewrittenBindVars, 0));
                    definition.binds = rewrittenBindVars;
                    if (definition.abstractSql[0] !== 'SelectQuery' &&
                        definition.abstractSql[0] !== 'Table') {
                        throw new Error('Only SelectQuery or Table definitions supported for inserts');
                    }
                    const tableName = unionResource.modifyName ?? unionResource.name;
                    const isTableBeingModified = (part) => (0, abstract_sql_compiler_1.isTableNode)(part) && part[1] === tableName;
                    if (isTableBeingModified(definition.abstractSql)) {
                        definition.abstractSql = bindVarSelectQuery;
                    }
                    else {
                        let found = false;
                        const replaceInsertTableNodeWithBinds = (part) => {
                            if ((0, abstract_sql_compiler_1.isFromNode)(part)) {
                                if (isTableBeingModified(part[1])) {
                                    found = true;
                                    return ['From', ['Alias', bindVarSelectQuery, tableName]];
                                }
                                else if ((0, abstract_sql_compiler_1.isAliasNode)(part[1])) {
                                    const [, aliasedNode, alias] = part[1];
                                    if (isTableBeingModified(aliasedNode)) {
                                        found = true;
                                        return ['From', ['Alias', bindVarSelectQuery, alias]];
                                    }
                                    else if (aliasedNode[0] === 'SelectQuery') {
                                        return [
                                            'From',
                                            [
                                                'Alias',
                                                aliasedNode.map(replaceInsertTableNodeWithBinds),
                                                alias,
                                            ],
                                        ];
                                    }
                                }
                            }
                            return part;
                        };
                        definition.abstractSql = definition.abstractSql.map(replaceInsertTableNodeWithBinds);
                        if (!found) {
                            throw new Error('Could not replace table entry in definition for insert');
                        }
                    }
                }
                const whereQuery = new Query();
                if (hasQueryOpts) {
                    this.AddQueryOptions(resource, path, whereQuery);
                }
                whereQuery.fromResource(this, unionResource, this, false, true);
                addPathKey = false;
                if (pathKeyWhere != null) {
                    whereQuery.where.push(pathKeyWhere);
                }
                subQuery.where.push(['Exists', whereQuery.compile('SelectQuery')]);
                query.extras.push(['Values', subQuery.compile('SelectQuery')]);
            }
            else {
                query.extras.push(['Values', bindVars.map((b) => b[1])]);
            }
        }
        else if (path.count) {
            this.AddCountField(path, query);
        }
        else if (method === 'GET') {
            this.AddSelectFields(path, query, resource);
        }
        if (addPathKey && pathKeyWhere != null) {
            query.where.push(pathKeyWhere);
        }
        if ((hasQueryOpts ||
            isDynamicResource(resource, this.alreadyComputedFields)) &&
            (method === 'PUT' || method === 'PATCH' || method === 'DELETE')) {
            const subQuery = new Query();
            subQuery.fromResource(this, resource);
            subQuery.addNestedFieldSelect(resource.idField, '$modifyid');
            if (hasQueryOpts) {
                this.AddQueryOptions(resource, path, subQuery);
            }
            query.where.push([
                'In',
                referencedIdField,
                subQuery.compile('SelectQuery'),
            ]);
        }
        else if (hasQueryOpts && method === 'GET') {
            this.AddQueryOptions(resource, path, query);
        }
        return query;
    }
    PathKey(method, path, resource, bodyKeys) {
        const { key } = path;
        if (key != null) {
            if (method === 'PUT' || method === 'PUT-INSERT' || method === 'POST') {
                if ((0, exports.isBindReference)(key)) {
                    addBodyKey(resource.resourceName, resource.idField, key, bodyKeys, this.extraBodyVars);
                }
                else {
                    for (const [fieldName, bind] of Object.entries(key)) {
                        addBodyKey(resource.resourceName, fieldName, bind, bodyKeys, this.extraBodyVars);
                    }
                }
            }
            if ((0, exports.isBindReference)(key)) {
                const bind = this.Bind(key);
                const referencedField = [
                    'ReferencedField',
                    resource.tableAlias,
                    resource.idField,
                ];
                return [comparison.eq, referencedField, bind];
            }
            const fieldNames = Object.keys(key);
            const sqlFieldNames = fieldNames.map(exports.odataNameToSqlName).sort();
            const fields = sqlFieldNames.map((fieldName) => {
                const resourceField = resource.fields.find((f) => f.fieldName === fieldName);
                if (resourceField == null) {
                    throw new SyntaxError('Specified non-existent field for path key');
                }
                return resourceField;
            });
            if (!(fields.length === 1 &&
                (fields[0].index === 'UNIQUE' || fields[0].index === 'PRIMARY KEY')) &&
                !resource.indexes.some((index) => {
                    return (((index.type === 'UNIQUE' && index.predicate == null) ||
                        index.type === 'PRIMARY KEY') &&
                        sqlFieldNames.length === index.fields.length &&
                        _.isEqual(index.fields.slice().sort(), sqlFieldNames));
                })) {
                throw new SyntaxError('Specified fields for path key that are not directly unique');
            }
            const namedKeys = fieldNames.map((fieldName) => {
                const bind = this.Bind(key[fieldName]);
                const referencedField = this.ReferencedField(resource, fieldName);
                return [comparison.eq, referencedField, bind];
            });
            if (namedKeys.length === 1) {
                return namedKeys[0];
            }
            return ['And', ...namedKeys];
        }
    }
    Bind(bind, optional = false) {
        if ((0, exports.isBindReference)(bind)) {
            return ['Bind', bind.bind];
        }
        if (optional) {
            return;
        }
        throw new SyntaxError(`Could not match bind reference`);
    }
    SelectFilter(filter, query, resource) {
        this.AddExtraFroms(query, resource, filter);
        const where = this.BooleanMatch(filter);
        query.where.push(where);
    }
    OrderBy(orderby, query, resource) {
        this.AddExtraFroms(query, resource, orderby.properties);
        query.extras.push([
            'OrderBy',
            ...this.OrderByProperties(orderby.properties),
        ]);
    }
    OrderByProperties(orderings) {
        return orderings.map((ordering) => {
            const field = this.ReferencedProperty(ordering);
            return [ordering.order.toUpperCase(), field];
        });
    }
    BindVars(method, bodyKeys, resourceName, match) {
        return match
            .map((field) => {
            const [fieldName, [, mappedFieldName]] = field;
            if (bodyKeys.includes(fieldName) ||
                bodyKeys.includes(resourceName + '.' + fieldName)) {
                return [mappedFieldName, ['Bind', resourceName, fieldName]];
            }
            if (method === 'PUT') {
                return [mappedFieldName, 'Default'];
            }
        })
            .filter((f) => f != null);
    }
    Resource(resourceName, parentResource) {
        const resourceAlias = this.resourceAliases[resourceName];
        if (resourceAlias) {
            return resourceAlias;
        }
        let resource;
        if (parentResource) {
            const relationshipMapping = this.ResolveRelationship(parentResource, resourceName);
            resource = this.clientModel.tables[relationshipMapping[1][0]];
        }
        else {
            let sqlName = (0, exports.odataNameToSqlName)(resourceName);
            sqlName = this.Synonym(sqlName);
            resource = this.clientModel.tables[sqlName];
        }
        if (!resource) {
            throw new SyntaxError('Could not match resource');
        }
        let tableAlias;
        if (parentResource) {
            let resourceAlias2;
            if (resourceName.includes('__') && !resource.name.includes('-')) {
                const verb = (0, exports.odataNameToSqlName)(resourceName).split('-')[0];
                resourceAlias2 = verb + '-' + resource.name;
            }
            else {
                resourceAlias2 = resource.name;
            }
            tableAlias = parentResource.tableAlias + '.' + resourceAlias2;
        }
        else {
            tableAlias = resource.name;
        }
        return {
            ...resource,
            tableAlias: this.checkAlias(tableAlias),
        };
    }
    FieldContainedIn(fieldName, resource) {
        try {
            this.ResolveRelationship(resource, fieldName);
            return true;
        }
        catch (e) {
            if (e instanceof SyntaxError) {
                return false;
            }
            throw e;
        }
    }
    ResourceMapping(resource, modifyFields = false) {
        const resourceMappingsProp = modifyFields === true && resource.modifyFields
            ? 'modifyResourceMappings'
            : 'resourceMappings';
        if (resource[resourceMappingsProp] == null) {
            const tableAlias = resource.tableAlias ?? resource.name;
            const resourceMappings = {};
            const fields = modifyFields === true && resource.modifyFields
                ? resource.modifyFields
                : resource.fields;
            for (const { fieldName } of fields) {
                resourceMappings[(0, exports.sqlNameToODataName)(fieldName)] = [
                    tableAlias,
                    fieldName,
                ];
            }
            resource[resourceMappingsProp] = resourceMappings;
        }
        return resource[resourceMappingsProp];
    }
    ResolveRelationship(resource, relationship) {
        let resourceName;
        if (typeof resource === 'object') {
            resourceName = resource.resourceName;
        }
        else if (this.resourceAliases[resource]) {
            resourceName = this.resourceAliases[resource].resourceName;
        }
        else {
            resourceName = resource;
        }
        resourceName = this.Synonym(resourceName);
        const resourceRelations = this.clientModel.relationships[resourceName];
        if (!resourceRelations) {
            throw new SyntaxError(`Could not resolve relationship for '${resourceName}'`);
        }
        const relationshipPath = _(relationship)
            .split('__')
            .map(exports.odataNameToSqlName)
            .flatMap((sqlName) => this.Synonym(sqlName).split('-'))
            .value();
        const relationshipMapping = _.get(resourceRelations, relationshipPath);
        if (!relationshipMapping?.$) {
            throw new SyntaxError(`Could not resolve relationship mapping from '${resourceName}' to '${relationshipPath}'`);
        }
        return relationshipMapping.$;
    }
    AddCountField(path, query) {
        if (path.count) {
            query.select.push(['Alias', ['Count', '*'], '$count']);
        }
    }
    AddSelectFields(path, query, resource) {
        let odataFieldNames;
        if (path.options?.$select?.properties) {
            this.AddExtraFroms(query, resource, path.options.$select.properties);
            odataFieldNames = path.options.$select.properties.map((prop) => {
                const field = this.Property(prop);
                const sqlName = (0, exports.odataNameToSqlName)(field.name);
                const resourceField = field.resource.fields.find(({ fieldName }) => fieldName === sqlName);
                return [field.resource, field.name, resourceField?.computed];
            });
        }
        else {
            odataFieldNames = resource.fields.map((field) => [
                resource,
                (0, exports.sqlNameToODataName)(field.fieldName),
                field.computed,
            ]);
        }
        const fields = _.differenceWith(odataFieldNames, query.select, (a, b) => a[1] === _.last(b)).map((args) => this.AliasSelectField(...args));
        query.select = query.select.concat(fields);
    }
    AliasSelectField(resource, fieldName, computed, alias = fieldName, forceCompilingComputedField = false) {
        const key = resource.name + '$' + fieldName;
        if (computed &&
            (!this.alreadyComputedFields[key] || forceCompilingComputedField)) {
            if (resource.tableAlias != null &&
                resource.tableAlias !== resource.name) {
                computed = rewriteComputed(computed, resource.name, resource.tableAlias);
            }
            this.alreadyComputedFields[key] = true;
            return ['Alias', computed, alias];
        }
        const referencedField = this.ReferencedField(resource, fieldName);
        if (referencedField[2] === alias) {
            return referencedField;
        }
        return ['Alias', referencedField, alias];
    }
    ReferencedField(resource, resourceField) {
        const mapping = this.ResourceMapping(resource);
        if (mapping[resourceField]) {
            return [
                'ReferencedField',
                mapping[resourceField][0],
                mapping[resourceField][1],
            ];
        }
        else {
            const relationshipMapping = this.ResolveRelationship(resource, resourceField);
            const tableAlias = resource.tableAlias ?? resource.name;
            if (relationshipMapping.length > 1 &&
                relationshipMapping[0] === resource.idField) {
                throw new SyntaxError('Attempted to directly fetch a virtual field: "' +
                    resourceField +
                    '"');
            }
            return ['ReferencedField', tableAlias, relationshipMapping[0]];
        }
    }
    BooleanMatch(match, optional = false) {
        switch (match) {
            case true:
            case false:
                return ['Boolean', match];
            default:
                if (Array.isArray(match)) {
                    const [type, ...rest] = match;
                    switch (type) {
                        case 'eq':
                        case 'ne':
                        case 'gt':
                        case 'ge':
                        case 'lt':
                        case 'le': {
                            const op1 = this.Operand(rest[0]);
                            const op2 = this.Operand(rest[1]);
                            return [comparison[type], op1, op2];
                        }
                        case 'and':
                        case 'or':
                            return [
                                _.capitalize(type),
                                ...rest.map((v) => this.BooleanMatch(v)),
                            ];
                        case 'not': {
                            const bool = this.BooleanMatch(rest[0]);
                            return ['Not', bool];
                        }
                        case 'in': {
                            return [
                                'In',
                                this.Operand(rest[0]),
                                ...rest[1].map((v) => this.Operand(v)),
                            ];
                        }
                        case 'call': {
                            const { method } = match[1];
                            switch (method) {
                                case 'contains':
                                case 'endswith':
                                case 'startswith':
                                case 'isof':
                                case 'substringof':
                                    return this.FunctionMatch(method, match);
                                default:
                                    if (optional) {
                                        return;
                                    }
                                    throw new SyntaxError(`${method} is not a boolean function`);
                            }
                        }
                        default:
                            if (optional) {
                                return;
                            }
                            throw new SyntaxError(`Boolean does not support ${type}`);
                    }
                }
                else if ((0, exports.isBindReference)(match)) {
                    return this.Bind(match);
                }
                else {
                    try {
                        return this.ReferencedProperty(match);
                    }
                    catch (e) {
                        if (optional) {
                            return;
                        }
                        throw e;
                    }
                }
        }
    }
    FunctionMatch(name, match, sqlName) {
        if (!Array.isArray(match) || match[0] !== 'call') {
            throw new SyntaxError('Not a function call');
        }
        const properties = match[1];
        if (properties.method !== name) {
            throw new SyntaxError('Unexpected function name');
        }
        const args = properties.args.map((v) => this.Operand(v));
        return [sqlName ?? _.capitalize(name), ...args];
    }
    Operand(match) {
        for (const matcher of [
            this.Bind,
            this.NullMatch,
            this.BooleanMatch,
            this.NumberMatch,
            this.TextMatch,
            this.DateMatch,
            this.DurationMatch,
            this.Math,
        ]) {
            const result = matcher.call(this, match, true);
            if (result) {
                return result;
            }
        }
        throw new SyntaxError('Could not match operand');
    }
    Math(match) {
        const [type, ...rest] = match;
        switch (type) {
            case 'add':
            case 'sub':
            case 'mul':
            case 'div':
                return [
                    operations[type],
                    this.Operand(rest[0]),
                    this.Operand(rest[1]),
                ];
            default:
                return;
        }
    }
    Lambda(resourceName, lambda) {
        const resourceAliases = this.resourceAliases;
        const defaultResource = this.defaultResource;
        try {
            const query = new Query();
            const resource = this.AddNavigation(query, this.defaultResource, resourceName);
            this.resourceAliases = { ...this.resourceAliases };
            this.resourceAliases[lambda.identifier] = resource;
            this.defaultResource = resource;
            this.AddExtraFroms(query, resource, lambda.expression);
            const filter = this.BooleanMatch(lambda.expression);
            if (lambda.method === 'any') {
                query.where.push(filter);
                return ['Exists', query.compile('SelectQuery')];
            }
            else if (lambda.method === 'all') {
                query.where.push(['Not', filter]);
                return ['Not', ['Exists', query.compile('SelectQuery')]];
            }
            else {
                throw new SyntaxError(`Lambda method does not support ${lambda.method}`);
            }
        }
        finally {
            this.resourceAliases = resourceAliases;
            this.defaultResource = defaultResource;
        }
    }
    ReferencedProperty(match) {
        const prop = this.Property(match);
        if (Array.isArray(prop)) {
            return prop;
        }
        else {
            let fieldDefinition;
            const mapping = this.ResourceMapping(prop.resource);
            if (mapping[prop.name]) {
                fieldDefinition = prop.resource.fields.find((f) => f.fieldName === mapping[prop.name][1]);
                if (fieldDefinition?.dataType === 'Date Time') {
                    return [
                        'DateTrunc',
                        ['EmbeddedText', 'milliseconds'],
                        this.ReferencedField(prop.resource, prop.name),
                    ];
                }
            }
            return this.ReferencedField(prop.resource, prop.name);
        }
    }
    Method(prop) {
        if (!prop.method) {
            throw new SyntaxError('Method is missing method entry');
        }
        if (prop.method[0] !== 'call') {
            throw new SyntaxError(`Invalid value for method invocation: ${prop.method[0]}`);
        }
        if (typeof prop.method[1] !== 'object') {
            throw new SyntaxError(`Invalid value for method invocation: ${prop.method[1]} should be an object`);
        }
        const { method } = prop.method[1];
        if (!Object.prototype.hasOwnProperty.call(this.methods, method)) {
            throw new SyntaxError(`Method ${method} is unknown`);
        }
        return this.methods[method].call(this, prop);
    }
    Property(prop) {
        if (!prop.name) {
            throw new SyntaxError('Property is missing name');
        }
        if (prop.property) {
            const defaultResource = this.defaultResource;
            let propResource;
            try {
                propResource = this.Resource(prop.name, this.defaultResource);
            }
            catch {
            }
            if (propResource) {
                try {
                    this.defaultResource = propResource;
                    return this.Property(prop.property);
                }
                finally {
                    this.defaultResource = defaultResource;
                }
            }
            else {
                return this.Property(prop.property);
            }
        }
        else if (prop.method) {
            return this.Method(prop);
        }
        else if (prop.lambda) {
            return this.Lambda(prop.name, prop.lambda);
        }
        else if (prop.count) {
            const query = new Query();
            query.select.push(['Count', '*']);
            const aliasedResource = this.AddNavigation(query, this.defaultResource, prop.name);
            if (prop.options?.$filter) {
                const defaultResource = this.defaultResource;
                this.defaultResource = aliasedResource;
                this.SelectFilter(prop.options.$filter, query, aliasedResource);
                this.defaultResource = defaultResource;
            }
            return query.compile('SelectQuery');
        }
        else {
            return { resource: this.defaultResource, name: prop.name };
        }
    }
    NumberMatch(match, optional = false) {
        if (typeof match === 'number') {
            return ['Number', match];
        }
        else if (Array.isArray(match) && match[0] === 'call') {
            const { method } = match[1];
            switch (method) {
                case 'indexof':
                case 'year':
                case 'month':
                case 'day':
                case 'hour':
                case 'minute':
                case 'second':
                case 'fractionalseconds':
                case 'totaloffsetminutes':
                case 'totalseconds':
                case 'round':
                case 'floor':
                case 'ceiling':
                    return this.FunctionMatch(method, match);
                case 'length':
                    return this.FunctionMatch('length', match, 'CharacterLength');
                default:
                    if (optional) {
                        return;
                    }
                    throw new SyntaxError(`${method} is not a number function`);
            }
        }
        else if ((0, exports.isBindReference)(match)) {
            return this.Bind(match);
        }
        else if (optional) {
            return;
        }
        else {
            throw new SyntaxError('Failed to match a Number entry');
        }
    }
    NullMatch(match) {
        if (match === null) {
            return ['Null'];
        }
    }
    TextMatch(match, optional = false) {
        if (typeof match === 'string') {
            return ['Text', match];
        }
        else if (Array.isArray(match) && match[0] === 'call') {
            const { method } = match[1];
            switch (method) {
                case 'tolower':
                    return this.FunctionMatch('tolower', match, 'Lower');
                case 'toupper':
                    return this.FunctionMatch('toupper', match, 'Upper');
                case 'concat':
                    return this.FunctionMatch('concat', match, 'Concatenate');
                case 'trim':
                case 'replace':
                    return this.FunctionMatch(method, match);
                case 'substring': {
                    const fn = this.FunctionMatch(method, match);
                    fn[2] = ['Add', fn[2], ['Number', 1]];
                    return fn;
                }
                default:
                    if (optional) {
                        return;
                    }
                    throw new SyntaxError(`${method} is not a number function`);
            }
        }
        else if (optional) {
            return;
        }
        else {
            throw new SyntaxError('Failed to match a Text entry');
        }
    }
    DateMatch(match, optional = false) {
        if (_.isDate(match)) {
            return ['Date', match];
        }
        else if (Array.isArray(match) && match[0] === 'call') {
            const { method } = match[1];
            switch (method) {
                case 'now':
                    return this.FunctionMatch('now', match, 'CurrentTimestamp');
                case 'maxdatetime':
                case 'mindatetime':
                    return this.FunctionMatch(method, match);
                case 'date':
                    return this.FunctionMatch('date', match, 'ToDate');
                case 'time':
                    return this.FunctionMatch('time', match, 'ToTime');
                default:
                    if (optional) {
                        return;
                    }
                    throw new SyntaxError(`${method} is not a date function`);
            }
        }
        else if (optional) {
            return;
        }
        else {
            throw new SyntaxError('Failed to match a Date entry');
        }
    }
    DurationMatch(match) {
        if (match == null || typeof match !== 'object') {
            return;
        }
        const duration = _(match)
            .pick('negative', 'day', 'hour', 'minute', 'second')
            .omitBy(_.isNil)
            .value();
        if (_(duration).omit('negative').isEmpty()) {
            return;
        }
        return ['Duration', duration];
    }
    Expands(resource, query, expands) {
        const defaultResource = this.defaultResource;
        for (const expand of expands) {
            const navigation = this.NavigateResources(resource, expand.name);
            const expandResource = navigation.resource;
            {
                this.defaultResource = expandResource;
            }
            const nestedExpandQuery = new Query();
            if (expand.property) {
                this.Expands(expandResource, nestedExpandQuery, [expand.property]);
            }
            if (expand.options?.$expand) {
                this.Expands(expandResource, nestedExpandQuery, expand.options.$expand.properties);
            }
            nestedExpandQuery.fromResource(this, expandResource);
            if (expand.count) {
                this.AddCountField(expand, nestedExpandQuery);
            }
            else {
                this.AddSelectFields(expand, nestedExpandQuery, expandResource);
            }
            this.AddQueryOptions(expandResource, expand, nestedExpandQuery);
            this.defaultResource = defaultResource;
            nestedExpandQuery.where.push(navigation.where);
            const expandQuery = new Query();
            expandQuery.select.push([
                'Alias',
                ['AggregateJSON', ['ReferencedField', expandResource.tableAlias, '*']],
                expand.name,
            ]);
            expandQuery.from.push([
                'Alias',
                nestedExpandQuery.compile('SelectQuery'),
                expandResource.tableAlias,
            ]);
            query.select.push([
                'Alias',
                expandQuery.compile('SelectQuery'),
                expand.name,
            ]);
        }
    }
    AddQueryOptions(resource, path, query) {
        if (!path.options) {
            return;
        }
        if (path.options.$filter) {
            this.SelectFilter(path.options.$filter, query, resource);
        }
        if (!path.count) {
            if (path.options.$orderby) {
                this.OrderBy(path.options.$orderby, query, resource);
            }
            if (path.options.$top) {
                const limit = this.NumberMatch(path.options.$top);
                query.extras.push(['Limit', limit]);
            }
            if (path.options.$skip) {
                const offset = this.NumberMatch(path.options.$skip);
                query.extras.push(['Offset', offset]);
            }
        }
    }
    NavigateResources(resource, navigation) {
        const relationshipMapping = this.ResolveRelationship(resource, navigation);
        const linkedResource = this.Resource(navigation, resource);
        const tableAlias = resource.tableAlias ?? resource.name;
        const linkedTableAlias = linkedResource.tableAlias ?? linkedResource.name;
        return {
            resource: linkedResource,
            where: [
                'Equals',
                ['ReferencedField', tableAlias, relationshipMapping[0]],
                ['ReferencedField', linkedTableAlias, relationshipMapping[1][1]],
            ],
        };
    }
    AddExtraFroms(query, parentResource, match) {
        try {
            if (Array.isArray(match)) {
                match.forEach((v) => {
                    this.AddExtraFroms(query, parentResource, v);
                });
            }
            else {
                let nextProp = match;
                let prop;
                while ((prop = nextProp) &&
                    prop.name &&
                    prop.property?.name) {
                    nextProp = prop.property;
                    const resourceAlias = this.resourceAliases[prop.name];
                    if (resourceAlias) {
                        parentResource = resourceAlias;
                    }
                    else {
                        parentResource = this.AddNavigation(query, parentResource, prop.name);
                    }
                }
                if (nextProp?.args) {
                    this.AddExtraFroms(query, parentResource, prop.args);
                }
            }
        }
        catch {
        }
    }
    AddNavigation(query, resource, extraResource) {
        const navigation = this.NavigateResources(resource, extraResource);
        if (!query.from.some((from) => ((0, abstract_sql_compiler_1.isTableNode)(from) && from[1] === navigation.resource.tableAlias) ||
            ((0, abstract_sql_compiler_1.isAliasNode)(from) && from[2] === navigation.resource.tableAlias))) {
            query.fromResource(this, navigation.resource);
            query.where.push(navigation.where);
            return navigation.resource;
        }
        else {
            throw new SyntaxError(`Could not navigate resources '${resource.name}' and '${extraResource}'`);
        }
    }
    reset() {
        this.putReset();
        this.extraBodyVars = {};
        this.extraBindVars = [];
        this.alreadyComputedFields = {};
    }
    putReset() {
        this.resourceAliases = {};
        this.defaultResource = undefined;
    }
    Synonym(sqlName) {
        return _(sqlName)
            .split('-')
            .map((namePart) => {
            const synonym = this.clientModel.synonyms[namePart];
            if (synonym) {
                return synonym;
            }
            return namePart;
        })
            .join('-');
    }
    getTableReference(resource, extraBindVars, bindVarsLength, bypassDefinition = false, tableAlias, isModifyOperation) {
        const maybeAlias = (tableRef) => {
            if (tableAlias == null) {
                return tableRef;
            }
            if ((0, abstract_sql_compiler_1.isTableNode)(tableRef) && tableRef[1] === tableAlias) {
                return tableRef;
            }
            else if ((0, abstract_sql_compiler_1.isAliasNode)(tableRef)) {
                if (tableRef[2] === tableAlias) {
                    return tableRef;
                }
                return ['Alias', tableRef[1], tableAlias];
            }
            else {
                return ['Alias', tableRef, tableAlias];
            }
        };
        if (bypassDefinition !== true) {
            if (resource.definition) {
                const definition = this.rewriteDefinition(resource.definition, extraBindVars, bindVarsLength);
                return maybeAlias(definition.abstractSql);
            }
            const computedFields = resource.fields.filter((f) => f.computed != null);
            if (computedFields.length > 0) {
                const computedFieldQuery = new Query();
                computedFieldQuery.select = [
                    ['Field', '*'],
                    ...computedFields.map((field) => this.AliasSelectField(resource, (0, exports.sqlNameToODataName)(field.fieldName), field.computed, field.fieldName, true)),
                ];
                computedFieldQuery.fromResource(this, {
                    tableAlias: resource.name,
                    ...resource,
                }, {
                    extraBindVars,
                    bindVarsLength,
                }, true);
                return maybeAlias(computedFieldQuery.compile('SelectQuery'));
            }
        }
        return maybeAlias([
            'Table',
            isModifyOperation && resource.modifyName
                ? resource.modifyName
                : resource.name,
        ]);
    }
    rewriteDefinition(definition, extraBindVars, bindVarsLength) {
        const rewrittenDefinition = _.cloneDeep(convertToModernDefinition(definition));
        (0, exports.rewriteBinds)(rewrittenDefinition, extraBindVars, bindVarsLength);
        modifyAbstractSql('Resource', rewrittenDefinition.abstractSql, (resource) => {
            const resourceName = resource[1];
            const referencedResource = this.clientModel.tables[resourceName];
            if (!referencedResource) {
                throw new Error(`Could not resolve resource ${resourceName}`);
            }
            const tableRef = this.getTableReference(referencedResource, extraBindVars, bindVarsLength);
            resource.splice(0, resource.length, ...tableRef);
        });
        return rewrittenDefinition;
    }
}
exports.OData2AbstractSQL = OData2AbstractSQL;
const addAliases = (shortAliases, origAliasParts) => {
    const trie = {};
    const buildTrie = (aliasPart) => {
        let node = trie;
        for (let i = 0; i < aliasPart.length; i++) {
            if (node.$suffix) {
                node[node.$suffix[0]] = {
                    $suffix: node.$suffix.slice(1),
                };
                delete node.$suffix;
            }
            const c = aliasPart[i];
            if (node[c]) {
                node = node[c];
            }
            else {
                node[c] = {
                    $suffix: aliasPart.slice(i + 1),
                };
                return;
            }
        }
    };
    const traverseNodes = (str, node) => {
        if (node.$suffix) {
            const index = lowerCaseAliasParts.indexOf(str + node.$suffix);
            const origAliasPart = origAliasParts[index];
            shortAliases[origAliasPart] = origAliasPart.slice(0, str.length);
        }
        else {
            _.forEach(node, (value, key) => {
                traverseNodes(str + key, value);
            });
        }
    };
    const lowerCaseAliasParts = origAliasParts.map((origAliasPart) => origAliasPart.toLowerCase());
    lowerCaseAliasParts.slice().sort().forEach(buildTrie);
    traverseNodes('', trie);
};
const getRelationships = (relationships, nestedRelationships = []) => {
    const relationshipKeys = Object.keys(relationships);
    for (const key of relationshipKeys) {
        if (key !== '$') {
            nestedRelationships.push(key);
            getRelationships(relationships[key], nestedRelationships);
        }
    }
    return nestedRelationships;
};
const generateShortAliases = (clientModel) => {
    const shortAliases = {};
    const aliasParts = _(getRelationships(clientModel.relationships))
        .union(Object.keys(clientModel.synonyms))
        .reject((key) => key === '$')
        .value();
    let origAliasParts = _(aliasParts)
        .flatMap((aliasPart) => aliasPart.split(/-| /))
        .uniq()
        .value();
    addAliases(shortAliases, origAliasParts);
    origAliasParts = _(aliasParts)
        .flatMap((aliasPart) => aliasPart.split('-'))
        .filter((aliasPart) => aliasPart.includes(' '))
        .map((aliasPart) => aliasPart
        .split(' ')
        .map((part) => shortAliases[part])
        .join(' '))
        .uniq()
        .value();
    addAliases(shortAliases, origAliasParts);
    origAliasParts = _(aliasParts)
        .filter((aliasPart) => aliasPart.includes('-'))
        .map((aliasPart) => aliasPart
        .split('-')
        .map((part) => shortAliases[part])
        .join('-'))
        .uniq()
        .value();
    addAliases(shortAliases, origAliasParts);
    return shortAliases;
};
//# sourceMappingURL=odata-to-abstract-sql.js.map