"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.websql = exports.mysql = exports.postgres = exports.compileRule = exports.isWhereNode = exports.isSelectNode = exports.isSelectQueryNode = exports.isResourceNode = exports.isTableNode = exports.isFromNode = exports.isAliasNode = exports.Engines = void 0;
var Engines;
(function (Engines) {
    Engines["postgres"] = "postgres";
    Engines["mysql"] = "mysql";
    Engines["websql"] = "websql";
})(Engines || (exports.Engines = Engines = {}));
const AbstractSQLOptimiser_1 = require("./AbstractSQLOptimiser");
const AbstractSQLRules2SQL_1 = require("./AbstractSQLRules2SQL");
const sbvr_types_1 = require("@balena/sbvr-types");
const _ = require("lodash");
const AbstractSQLSchemaOptimiser_1 = require("./AbstractSQLSchemaOptimiser");
const referenced_fields_1 = require("./referenced-fields");
const validateTypes = _.mapValues(sbvr_types_1.default, ({ validate }) => validate);
const dataTypeValidate = async (value, field) => {
    const { dataType, required = false } = field;
    const validateFn = validateTypes[dataType];
    if (validateFn != null) {
        return validateFn(value, required);
    }
    else {
        return new Error('is an unsupported type: ' + dataType);
    }
};
const dataTypeGen = (engine, { dataType, required, index, defaultValue, checks }) => {
    let requiredStr;
    if (required) {
        requiredStr = ' NOT NULL';
    }
    else {
        requiredStr = ' NULL';
    }
    if (defaultValue != null) {
        defaultValue = ` DEFAULT ${defaultValue}`;
    }
    else {
        defaultValue = '';
    }
    let checksString = '';
    if (checks != null) {
        checksString = checks
            .map((check) => {
            return ` CHECK (${compileRule(check, engine, true)})`;
        })
            .join('');
    }
    if (index == null) {
        index = '';
    }
    else if (index !== '') {
        index = ' ' + index;
    }
    const dbType = sbvr_types_1.default?.[dataType]?.types?.[engine];
    if (dbType != null) {
        if (typeof dbType === 'function') {
            return dbType(requiredStr, index);
        }
        return dbType + defaultValue + requiredStr + checksString + index;
    }
    else {
        throw new Error(`Unknown data type '${dataType}' for engine: ${engine}`);
    }
};
const isAliasNode = (n) => n[0] === 'Alias';
exports.isAliasNode = isAliasNode;
const isFromNode = (n) => n[0] === 'From';
exports.isFromNode = isFromNode;
const isTableNode = (n) => n[0] === 'Table';
exports.isTableNode = isTableNode;
const isResourceNode = (n) => n[0] === 'Resource';
exports.isResourceNode = isResourceNode;
const isSelectQueryNode = (n) => n[0] === 'SelectQuery';
exports.isSelectQueryNode = isSelectQueryNode;
const isSelectNode = (n) => n[0] === 'Select';
exports.isSelectNode = isSelectNode;
const isWhereNode = (n) => n[0] === 'Where';
exports.isWhereNode = isWhereNode;
const containsNode = (n, checkNodeTypeFn) => {
    if (checkNodeTypeFn(n)) {
        return true;
    }
    for (const p of n) {
        if (Array.isArray(p) && containsNode(p, checkNodeTypeFn)) {
            return true;
        }
    }
    return false;
};
function compileRule(abstractSQL, engine, noBinds = false) {
    abstractSQL = (0, AbstractSQLOptimiser_1.AbstractSQLOptimiser)(abstractSQL, noBinds);
    return (0, AbstractSQLRules2SQL_1.AbstractSQLRules2SQL)(abstractSQL, engine, noBinds);
}
exports.compileRule = compileRule;
const compileSchema = (abstractSqlModel, engine, ifNotExists) => {
    abstractSqlModel = (0, AbstractSQLSchemaOptimiser_1.optimizeSchema)(abstractSqlModel, false);
    let ifNotExistsStr = '';
    let orReplaceStr = '';
    if (ifNotExists) {
        ifNotExistsStr = 'IF NOT EXISTS ';
        orReplaceStr = 'OR REPLACE ';
    }
    const createSchemaStatements = [];
    const alterSchemaStatements = [];
    let dropSchemaStatements = [];
    const fns = {};
    if (abstractSqlModel.functions) {
        for (const fnName of Object.keys(abstractSqlModel.functions)) {
            const fnDefinition = abstractSqlModel.functions[fnName];
            if (engine !== "postgres") {
                throw new Error('Functions are only supported on postgres currently');
            }
            if (fnDefinition.language !== 'plpgsql') {
                throw new Error('Only plpgsql functions currently supported');
            }
            if (fnDefinition.type !== 'trigger') {
                throw new Error('Only trigger functions currently supported');
            }
            fns[fnName] = true;
            createSchemaStatements.push(`\
DO $$
BEGIN
	PERFORM '"${fnName}"()'::regprocedure;
EXCEPTION WHEN undefined_function THEN
	CREATE FUNCTION "${fnName}"()
	RETURNS TRIGGER AS $fn$
	BEGIN
		${fnDefinition.body}
	END;
	$fn$ LANGUAGE ${fnDefinition.language};
END;
$$;`);
            dropSchemaStatements.push(`DROP FUNCTION "${fnName}"();`);
        }
    }
    const hasDependants = {};
    const schemaDependencyMap = {};
    Object.keys(abstractSqlModel.tables).forEach((resourceName) => {
        const table = abstractSqlModel.tables[resourceName];
        if (typeof table === 'string') {
            return;
        }
        const { definition } = table;
        if (definition != null) {
            if (definition.binds != null && definition.binds.length > 0) {
                return;
            }
            let definitionAbstractSql = definition.abstractSql;
            if (containsNode(definitionAbstractSql, exports.isResourceNode)) {
                return;
            }
            if ((0, exports.isTableNode)(definitionAbstractSql)) {
                definitionAbstractSql = [
                    'SelectQuery',
                    ['Select', [['Field', '*']]],
                    ['From', definitionAbstractSql],
                ];
            }
            schemaDependencyMap[table.resourceName] = {
                resourceName,
                primitive: table.primitive,
                createSQL: [
                    `\
CREATE ${orReplaceStr}VIEW "${table.name}" AS (
${compileRule(definitionAbstractSql, engine, true).replace(/^/gm, '	')}
);`,
                ],
                dropSQL: [`DROP VIEW "${table.name}";`],
                depends: [],
            };
            return;
        }
        const foreignKeys = [];
        const depends = [];
        const createSqlElements = [];
        const createIndexes = [];
        for (const field of table.fields) {
            const { fieldName, references, dataType, computed } = field;
            if (!computed) {
                createSqlElements.push('"' + fieldName + '" ' + dataTypeGen(engine, field));
                if (['ForeignKey', 'ConceptType'].includes(dataType) &&
                    references != null) {
                    const referencedTable = abstractSqlModel.tables[references.resourceName];
                    const fkDefinition = `FOREIGN KEY ("${fieldName}") REFERENCES "${referencedTable.name}" ("${references.fieldName}")`;
                    const schemaInfo = schemaDependencyMap[references.resourceName];
                    if (schemaInfo && schemaInfo.depends.includes(table.resourceName)) {
                        if (engine !== "postgres") {
                            throw new Error('Circular dependencies are only supported on postgres currently');
                        }
                        alterSchemaStatements.push(`\
DO $$
BEGIN
	IF NOT EXISTS (
		SELECT 1
		FROM information_schema.table_constraints tc
		JOIN information_schema.key_column_usage kcu USING (constraint_catalog, constraint_schema, constraint_name)
		JOIN information_schema.constraint_column_usage ccu USING (constraint_catalog, constraint_schema, constraint_name)
		WHERE constraint_type = 'FOREIGN KEY'
			AND tc.table_schema = CURRENT_SCHEMA()
			AND tc.table_name = '${table.name}'
			AND kcu.column_name = '${fieldName}'
			AND ccu.table_schema = CURRENT_SCHEMA()
			AND ccu.table_name = '${referencedTable.name}'
			AND ccu.column_name = '${references.fieldName}'
	) THEN
		ALTER TABLE "${table.name}"
		ADD CONSTRAINT "${table.name}_${fieldName}_fkey"
		${fkDefinition};
	END IF;
END;
$$;`);
                    }
                    else {
                        if (references.type !== 'informative') {
                            foreignKeys.push(fkDefinition);
                        }
                        depends.push(references.resourceName);
                        hasDependants[references.resourceName] = true;
                    }
                }
            }
        }
        createSqlElements.push(...foreignKeys);
        for (const index of table.indexes) {
            let nullsSql = '';
            if (index.distinctNulls != null) {
                nullsSql =
                    index.distinctNulls === false
                        ? ` NULLS NOT DISTINCT`
                        : ` NULLS DISTINCT`;
            }
            if (index.predicate == null) {
                createSqlElements.push(index.type + nullsSql + '("' + index.fields.join('", "') + '")');
                continue;
            }
            if (index.name == null) {
                throw new Error('No name provided for partial index');
            }
            const comment = index.description
                ? `-- ${index.description.replaceAll(/\r?\n/g, '\n-- ')}\n`
                : '';
            const whereSql = compileRule(index.predicate, engine, true);
            createIndexes.push(`\
${comment}\
CREATE ${index.type} INDEX IF NOT EXISTS "${index.name}"
ON "${table.name}" ("${index.fields.join('", "')}")${nullsSql}
WHERE (${whereSql});`);
        }
        if (table.checks) {
            for (const check of table.checks) {
                const comment = check.description
                    ? `-- ${check.description.split(/\r?\n/).join('\n-- ')}\n`
                    : '';
                const constraintName = check.name ? `CONSTRAINT "${check.name}" ` : '';
                const sql = compileRule(check.abstractSql, engine, true);
                createSqlElements.push(`\
${comment}${constraintName}CHECK (${sql})`);
            }
        }
        const createTriggers = [];
        const dropTriggers = [];
        if (table.triggers) {
            for (const trigger of table.triggers) {
                if (!fns[trigger.fnName]) {
                    throw new Error(`No such function '${trigger.fnName}' declared`);
                }
                const triggerName = `${table.name}_${trigger.fnName}`.slice(0, 63);
                createTriggers.push(`\
DO
$$
BEGIN
IF NOT EXISTS(
	SELECT 1
	FROM "information_schema"."triggers"
	WHERE "event_object_table" = '${table.name}'
	AND "trigger_name" = '${triggerName}'
) THEN
	CREATE TRIGGER "${triggerName}"
	${trigger.when} ${trigger.operation} ON "${table.name}"
	FOR EACH ${trigger.level}
	EXECUTE PROCEDURE "${trigger.fnName}"();
END IF;
END;
$$`);
                dropTriggers.push(`DROP TRIGGER "${triggerName}";`);
            }
        }
        schemaDependencyMap[table.resourceName] = {
            resourceName,
            primitive: table.primitive,
            createSQL: [
                `\
CREATE TABLE ${ifNotExistsStr}"${table.name}" (
	${createSqlElements.join('\n,\t')}
);`,
                ...createIndexes,
                ...createTriggers,
            ],
            dropSQL: [...dropTriggers, `DROP TABLE "${table.name}";`],
            depends,
        };
    });
    let resourceNames = [];
    while (resourceNames.length !==
        (resourceNames = Object.keys(schemaDependencyMap)).length &&
        resourceNames.length > 0) {
        for (const resourceName of resourceNames) {
            const schemaInfo = schemaDependencyMap[resourceName];
            let unsolvedDependency = false;
            for (const dependency of schemaInfo.depends) {
                if (dependency !== resourceName &&
                    Object.prototype.hasOwnProperty.call(schemaDependencyMap, dependency)) {
                    unsolvedDependency = true;
                    break;
                }
            }
            if (unsolvedDependency === false) {
                if (schemaInfo.primitive === false ||
                    hasDependants[resourceName] != null) {
                    if (schemaInfo.primitive !== false) {
                        console.warn("We're adding a primitive table??", schemaInfo.resourceName);
                    }
                    createSchemaStatements.push(...schemaInfo.createSQL);
                    dropSchemaStatements.push(...schemaInfo.dropSQL);
                }
                delete schemaDependencyMap[resourceName];
            }
        }
    }
    if (Object.keys(schemaDependencyMap).length > 0) {
        console.error('Failed to resolve all schema dependencies', schemaDependencyMap);
        throw new Error('Failed to resolve all schema dependencies');
    }
    createSchemaStatements.push(...alterSchemaStatements);
    dropSchemaStatements = dropSchemaStatements.reverse();
    const ruleStatements = abstractSqlModel.rules.map((rule) => {
        const ruleBodyNode = rule.find((r) => r[0] === 'Body');
        if (ruleBodyNode == null || typeof ruleBodyNode === 'string') {
            throw new Error('Invalid rule');
        }
        const ruleBody = ruleBodyNode[1];
        if (typeof ruleBody === 'string') {
            throw new Error('Invalid rule');
        }
        const ruleSENode = rule.find((r) => r[0] === 'StructuredEnglish');
        if (ruleSENode == null) {
            throw new Error('Invalid structured English');
        }
        const ruleSE = ruleSENode[1];
        if (typeof ruleSE !== 'string') {
            throw new Error('Invalid structured English');
        }
        (0, referenced_fields_1.insertAffectedIdsBinds)(ruleBody, abstractSqlModel.lfInfo.rules[ruleSE]);
        const { query: ruleSQL, bindings: ruleBindings } = compileRule(ruleBody, engine);
        let referencedFields;
        try {
            referencedFields = (0, referenced_fields_1.getReferencedFields)(ruleBody);
        }
        catch (e) {
            console.warn('Error fetching referenced fields', e);
        }
        let ruleReferencedFields;
        try {
            ruleReferencedFields = (0, referenced_fields_1.getRuleReferencedFields)(ruleBody);
        }
        catch (e) {
            console.warn('Error fetching rule referenced fields', e);
        }
        return {
            structuredEnglish: ruleSE,
            sql: ruleSQL,
            bindings: ruleBindings,
            referencedFields,
            ruleReferencedFields,
        };
    });
    return {
        synonyms: abstractSqlModel.synonyms,
        relationships: abstractSqlModel.relationships,
        tables: abstractSqlModel.tables,
        createSchema: createSchemaStatements,
        dropSchema: dropSchemaStatements,
        rules: ruleStatements,
    };
};
const generateExport = (engine, ifNotExists) => {
    return {
        optimizeSchema: AbstractSQLSchemaOptimiser_1.optimizeSchema,
        generateRuleSlug: AbstractSQLSchemaOptimiser_1.generateRuleSlug,
        compileSchema: (abstractSqlModel) => compileSchema(abstractSqlModel, engine, ifNotExists),
        compileRule: (abstractSQL) => compileRule(abstractSQL, engine, false),
        dataTypeValidate,
        getReferencedFields: referenced_fields_1.getReferencedFields,
        getRuleReferencedFields: referenced_fields_1.getRuleReferencedFields,
        getModifiedFields: referenced_fields_1.getModifiedFields,
    };
};
exports.postgres = generateExport("postgres", true);
exports.mysql = generateExport("mysql", true);
exports.websql = generateExport("websql", false);
//# sourceMappingURL=AbstractSQLCompiler.js.map