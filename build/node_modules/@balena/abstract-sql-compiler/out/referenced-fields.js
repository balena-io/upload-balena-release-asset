"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertAffectedIdsBinds = exports.getModifiedFields = exports.getRuleReferencedFields = exports.getReferencedFields = void 0;
const _ = require("lodash");
const AbstractSQLCompiler_1 = require("./AbstractSQLCompiler");
const AbstractSQLOptimiser_1 = require("./AbstractSQLOptimiser");
const AbstractSQLRules2SQL_1 = require("./AbstractSQLRules2SQL");
const getReferencedFields = (ruleBody) => {
    const referencedFields = (0, exports.getRuleReferencedFields)(ruleBody);
    return _.mapValues(referencedFields, ({ update }) => _.uniq(update));
};
exports.getReferencedFields = getReferencedFields;
var IsSafe;
(function (IsSafe) {
    IsSafe["Insert"] = "ins";
    IsSafe["Delete"] = "del";
    IsSafe["Unknown"] = "";
})(IsSafe || (IsSafe = {}));
const getRuleReferencedScope = (rulePart, scope, isSafe) => {
    const currentlyScopedAliases = [];
    scope = { ...scope };
    const fromNodes = rulePart.filter(AbstractSQLCompiler_1.isFromNode);
    fromNodes.forEach((node) => {
        const nested = node[1];
        if (nested[0] === 'Alias') {
            const [, from, alias] = nested;
            if (typeof alias !== 'string') {
                throw new Error('Cannot handle non-string aliases');
            }
            currentlyScopedAliases.push(alias);
            switch (from[0]) {
                case 'Table':
                    scope[alias] = { tableName: from[1], isSafe };
                    break;
                case 'SelectQuery':
                    scope[alias] = { tableName: '', isSafe };
                    break;
                default:
                    throw new Error(`Cannot handle aliased ${from[0]} nodes`);
            }
        }
        else if (nested[0] === 'Table') {
            currentlyScopedAliases.push(nested[1]);
            scope[nested[1]] = { tableName: nested[1], isSafe };
        }
        else {
            throw Error(`Unsupported FromNode for scoping: ${nested[0]}`);
        }
    });
    return { scope, currentlyScopedAliases };
};
const addReference = (referencedFields, scope, aliasName, fieldName) => {
    const a = scope[aliasName];
    if (a.tableName !== '') {
        referencedFields[a.tableName] ??= {
            create: [],
            update: [],
            delete: [],
        };
        if (a.isSafe !== IsSafe.Insert) {
            referencedFields[a.tableName].create.push(fieldName);
        }
        if (a.isSafe !== IsSafe.Delete) {
            referencedFields[a.tableName].delete.push(fieldName);
        }
        referencedFields[a.tableName].update.push(fieldName);
    }
};
const $getRuleReferencedFields = (referencedFields, rulePart, isSafe, { scope, currentlyScopedAliases, } = {
    scope: {},
    currentlyScopedAliases: [],
}) => {
    if (!Array.isArray(rulePart)) {
        return;
    }
    switch (rulePart[0]) {
        case 'SelectQuery':
            ({ scope, currentlyScopedAliases } = getRuleReferencedScope(rulePart, scope, isSafe));
            rulePart.forEach((node) => {
                $getRuleReferencedFields(referencedFields, node, isSafe, {
                    scope,
                    currentlyScopedAliases,
                });
            });
            return;
        case 'ReferencedField': {
            const [, aliasName, fieldName] = rulePart;
            if (typeof aliasName !== 'string' || typeof fieldName !== 'string') {
                throw new Error(`Invalid ReferencedField: ${rulePart}`);
            }
            addReference(referencedFields, scope, aliasName, fieldName);
            return;
        }
        case 'Field': {
            const [, fieldName] = rulePart;
            if (typeof fieldName !== 'string') {
                throw new Error(`Invalid ReferencedField: ${rulePart}`);
            }
            for (const aliasName of Object.keys(scope)) {
                addReference(referencedFields, scope, aliasName, fieldName);
            }
            return;
        }
        case 'Not':
        case 'NotExists':
            if (isSafe === IsSafe.Insert) {
                isSafe = IsSafe.Delete;
            }
            else if (isSafe === IsSafe.Delete) {
                isSafe = IsSafe.Insert;
            }
        case 'Where':
        case 'And':
        case 'Exists':
            rulePart.forEach((node) => {
                $getRuleReferencedFields(referencedFields, node, isSafe, {
                    scope,
                    currentlyScopedAliases,
                });
            });
            return;
        case 'Having':
            scope = { ...scope };
            for (const key of Object.keys(scope)) {
                scope[key] = { ...scope[key], isSafe: IsSafe.Unknown };
            }
            rulePart.forEach((node) => {
                $getRuleReferencedFields(referencedFields, node, isSafe, {
                    scope,
                    currentlyScopedAliases,
                });
            });
            return;
        case 'Count':
            if (rulePart[1] !== '*') {
                throw new Error('Only COUNT(*) is supported for rule referenced fields');
            }
            for (const aliasName of currentlyScopedAliases) {
                addReference(referencedFields, scope, aliasName, '');
            }
            return;
        default:
            rulePart.forEach((node) => {
                $getRuleReferencedFields(referencedFields, node, IsSafe.Unknown, {
                    scope,
                    currentlyScopedAliases,
                });
            });
    }
};
const getRuleReferencedFields = (ruleBody) => {
    ruleBody = (0, AbstractSQLOptimiser_1.AbstractSQLOptimiser)(ruleBody);
    const referencedFields = {};
    if (ruleBody[0] === 'Equals' &&
        _.isEqual(ruleBody[2], ['Number', 0]) &&
        (0, AbstractSQLCompiler_1.isSelectQueryNode)(ruleBody[1])) {
        const select = ruleBody[1].find(AbstractSQLCompiler_1.isSelectNode);
        select[1] = [];
        $getRuleReferencedFields(referencedFields, ruleBody[1], IsSafe.Delete);
    }
    else {
        $getRuleReferencedFields(referencedFields, ruleBody, IsSafe.Insert);
    }
    for (const tableName of Object.keys(referencedFields)) {
        const tableRefs = referencedFields[tableName];
        for (const method of Object.keys(tableRefs)) {
            tableRefs[method] = _.uniq(tableRefs[method]);
        }
    }
    return referencedFields;
};
exports.getRuleReferencedFields = getRuleReferencedFields;
const checkQuery = (query) => {
    const queryType = query[0];
    if (!['InsertQuery', 'UpdateQuery', 'DeleteQuery'].includes(queryType)) {
        return;
    }
    const froms = query.filter(AbstractSQLCompiler_1.isFromNode);
    if (froms.length !== 1) {
        return;
    }
    let table = froms[0][1];
    if ((0, AbstractSQLCompiler_1.isAliasNode)(table)) {
        table = table[1];
    }
    let tableName;
    if ((0, AbstractSQLCompiler_1.isTableNode)(table)) {
        tableName = table[1];
    }
    else if (typeof table === 'string') {
        tableName = table;
    }
    else {
        return;
    }
    if (queryType === 'InsertQuery') {
        return { table: tableName, action: 'create' };
    }
    if (queryType === 'DeleteQuery') {
        return { table: tableName, action: 'delete' };
    }
    const fields = _(query)
        .filter((v) => v != null && v[0] === 'Fields')
        .flatMap((v) => v[1])
        .value();
    return { table: tableName, action: 'update', fields };
};
const getModifiedFields = (abstractSqlQuery) => {
    if (abstractSqlQuery[0] === 'UpsertQuery') {
        return abstractSqlQuery.slice(1).map(checkQuery);
    }
    else if (Array.isArray(abstractSqlQuery[0])) {
        return abstractSqlQuery.map(checkQuery);
    }
    else {
        return checkQuery(abstractSqlQuery);
    }
};
exports.getModifiedFields = getModifiedFields;
function assertAbstractSqlIsNotLegacy(abstractSql) {
    if (!(0, AbstractSQLRules2SQL_1.isAbstractSqlQuery)(abstractSql)) {
        throw new Error('cannot introspect into the string form of AbstractSqlQuery');
    }
}
const countTableSelects = (abstractSql, table) => {
    assertAbstractSqlIsNotLegacy(abstractSql);
    let sum = 0;
    switch (abstractSql[0]) {
        case 'Alias':
        case 'Any':
        case 'Average':
        case 'Cast':
        case 'CharacterLength':
        case 'CrossJoin':
        case 'Exists':
        case 'From':
        case 'Having':
        case 'Not':
        case 'NotExists':
        case 'Sum':
        case 'ToJSON':
        case 'Where': {
            const unaryOperation = abstractSql;
            assertAbstractSqlIsNotLegacy(unaryOperation[1]);
            return countTableSelects(unaryOperation[1], table);
        }
        case 'Count': {
            const countNode = abstractSql;
            if (countNode[1] !== '*') {
                throw new Error('Only COUNT(*) is supported');
            }
            return 0;
        }
        case 'AddDateDuration':
        case 'AddDateNumber':
        case 'DateTrunc':
        case 'Equals':
        case 'ExtractJSONPathAsText':
        case 'GreaterThan':
        case 'GreaterThanOrEqual':
        case 'IsDistinctFrom':
        case 'IsNotDistinctFrom':
        case 'LessThan':
        case 'LessThanOrEqual':
        case 'NotEquals':
        case 'SubtractDateDate':
        case 'SubtractDateDuration':
        case 'SubtractDateNumber': {
            const binaryOperation = abstractSql;
            const leftOperand = binaryOperation[1];
            assertAbstractSqlIsNotLegacy(leftOperand);
            const rightOperand = binaryOperation[2];
            assertAbstractSqlIsNotLegacy(rightOperand);
            return (countTableSelects(leftOperand, table) +
                countTableSelects(rightOperand, table));
        }
        case 'FullJoin':
        case 'Join':
        case 'LeftJoin':
        case 'RightJoin': {
            const joinNode = abstractSql;
            assertAbstractSqlIsNotLegacy(joinNode[1]);
            if (joinNode[2] !== undefined) {
                assertAbstractSqlIsNotLegacy(joinNode[2][1]);
                sum = countTableSelects(joinNode[2][1], table);
            }
            return sum + countTableSelects(joinNode[1], table);
        }
        case 'And':
        case 'Or':
        case 'SelectQuery':
        case 'TextArray':
        case 'UnionQuery': {
            const selectQueryNode = abstractSql;
            for (const arg of selectQueryNode.slice(1)) {
                assertAbstractSqlIsNotLegacy(arg);
                sum += countTableSelects(arg, table);
            }
            return sum;
        }
        case 'In':
        case 'NotIn': {
            const inNode = abstractSql;
            for (const arg of inNode.slice(2)) {
                assertAbstractSqlIsNotLegacy(arg);
                sum += countTableSelects(arg, table);
            }
            return sum;
        }
        case 'Select': {
            const selectNode = abstractSql;
            for (const arg of selectNode[1]) {
                assertAbstractSqlIsNotLegacy(arg);
                sum += countTableSelects(arg, table);
            }
            return sum;
        }
        case 'Boolean':
        case 'Date':
        case 'Duration':
        case 'EmbeddedText':
        case 'GroupBy':
        case 'Integer':
        case 'Null':
        case 'Number':
        case 'ReferencedField':
        case 'Text':
            return 0;
        case 'Table': {
            const tableNode = abstractSql;
            if (tableNode[1] === table) {
                return 1;
            }
            else {
                return 0;
            }
        }
        default:
            throw new Error(`unknown abstract sql type: ${abstractSql[0]}`);
    }
};
const insertAffectedIdsBinds = (abstractSql, lfRuleInfo) => {
    const rootTableSelectCount = countTableSelects(abstractSql, lfRuleInfo.root.table);
    if (rootTableSelectCount !== 1) {
        return;
    }
    const narrowing = [
        'Or',
        ['Equals', ['Bind', lfRuleInfo.root.table], ['EmbeddedText', '{}']],
        [
            'Equals',
            ['ReferencedField', lfRuleInfo.root.alias, 'id'],
            ['Any', ['Bind', lfRuleInfo.root.table], 'Integer'],
        ],
    ];
    if (abstractSql[0] !== 'Equals' ||
        abstractSql[1][0] !== 'SelectQuery' ||
        abstractSql[2][0] !== 'Number') {
        throw new Error('Query is not of the form: SELECT (SELECT COUNT(*) ...) = 0');
    }
    const selectQueryNode = abstractSql[1];
    const whereNode = selectQueryNode.slice(1).find(AbstractSQLCompiler_1.isWhereNode);
    if (whereNode === undefined) {
        selectQueryNode.push(['Where', narrowing]);
    }
    else {
        whereNode[1] = ['And', whereNode[1], narrowing];
    }
};
exports.insertAffectedIdsBinds = insertAffectedIdsBinds;
//# sourceMappingURL=referenced-fields.js.map