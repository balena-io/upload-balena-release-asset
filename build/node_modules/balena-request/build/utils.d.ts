import type BalenaAuth from 'balena-auth';
import type { BalenaRequestOptions, BalenaRequestResponse } from './request';
import { Readable } from 'stream';
/**
 * @module utils
 */
export declare const TOKEN_REFRESH_INTERVAL: number;
/**
 * @summary Determine if the token should be updated
 * @function
 * @protected
 *
 * @description
 * This function makes use of a soft user-configurable setting called `tokenRefreshInterval`.
 * That setting doesn't express that the token is "invalid", but represents that it is a good time for the token to be updated *before* it get's outdated.
 *
 * @param {object} auth - an instance of `balena-auth`
 * @returns {Promise<Boolean>} the token should be updated
 *
 * @example
 * tokenUtils.shouldRefreshKey(tokenInstance).then (shouldRefreshKey) ->
 * 		if shouldRefreshKey
 * 			console.log('Updating token!')
 */
export declare function shouldRefreshKey(auth: BalenaAuth): Promise<boolean>;
/**
 * @summary Get authorization header content
 * @function
 * @protected
 *
 * @description
 * This promise becomes undefined if no saved token.
 *
 * @param {object} auth - an instance of `balena-auth`
 * @returns {Promise<string | undefined>} authorization header
 *
 * @example
 * utils.getAuthorizationHeader(tokenInstance).then (authorizationHeader) ->
 * 		headers =
 * 			Authorization: authorizationHeader
 */
export declare function getAuthorizationHeader(auth: BalenaAuth | undefined): Promise<string | undefined>;
/**
 * @summary Get error message from response
 * @function
 * @protected
 *
 * @param {Object} response - node request response
 * @returns {String} error message
 *
 * @example
 * request
 * 		method: 'GET'
 * 		url: 'https://foo.bar'
 * 	, (error, response) ->
 * 		throw error if error?
 * 		message = utils.getErrorMessageFromResponse(response)
 */
export declare function getErrorMessageFromResponse(response: BalenaRequestResponse): any;
/**
 * @summary Check if the status code represents an error
 * @function
 * @protected
 *
 * @param {Number} statusCode - status code
 * @returns {Boolean} represents an error
 *
 * @example
 * if utils.isErrorCode(400)
 * 		console.log('400 is an error code!')
 */
export declare function isErrorCode(statusCode: number): boolean;
/**
 * @summary Check whether a response body is compressed
 * @function
 * @protected
 *
 * @param {Object} response - request response object
 * @returns {Boolean} whether the response body is compressed
 *
 * @example
 * if utils.isResponseCompressed(response)
 * 	console.log('The response body is compressed')
 */
export declare function isResponseCompressed(response: BalenaRequestResponse): boolean;
/**
 * @summary Get response compressed/uncompressed length
 * @function
 * @protected
 *
 * @param {Object} response - request response object
 * @returns {Object} response length
 *
 * @example
 * responseLength = utils.getResponseLength(response)
 * console.log(responseLength.compressed)
 * console.log(responseLength.uncompressed)
 */
export declare function getResponseLength(response: BalenaRequestResponse): {
    uncompressed: number | undefined;
    compressed: number | undefined;
};
/**
 * @summary Print debug information about a request/response.
 * @function
 * @protected
 *
 * @param {Object} options - request options
 * @param {Object} response - request response
 *
 * @example
 * options = {
 * 	method: 'GET'
 * 	 url: '/foo'
 * }
 *
 * request(options).spread (response) ->
 * 	utils.debugRequest(options, response)
 */
export declare function debugRequest(options: BalenaRequestOptions, response: BalenaRequestResponse): void;
/**
 * @summary Extract the body from the server response
 * @function
 * @protected
 *
 * @param {Response} response
 * @param {String} [responseFormat] - explicit expected response format,
 * can be one of 'blob', 'json', 'text', 'none'. Defaults to sniffing the content-type
 *
 * @example
 * utils.getBody(response).then (body) ->
 * 	console.log(body)
 */
export declare function getBody(response: BalenaRequestResponse, responseFormat?: string): Promise<any>;
/**
 * @summary The factory that returns the `requestAsync` function.
 * @function
 * @protected
 *
 * @param {Function} [fetch] - the fetch implementation, defaults to that returned by `fetch-ponyfill`.
 *
 * @description The returned function keeps partial compatibility with promisified `request`
 * but uses `fetch` behind the scenes.
 * It accepts the `options` object.
 *
 * @example
 * utils.getRequestAsync()({ url: 'http://example.com' }).then (response) ->
 * 	console.log(response)
 */
export declare function getRequestAsync($fetch?: typeof fetch): (options: BalenaRequestOptions) => Promise<BalenaRequestResponse<any>>;
/**
 * @summary A function that returns the contents of a stream
 * @function
 * @protected
 *
 * @param {Readable} [stream] - the stream to get the contents of
 */
export declare function getStreamContents(stream: Readable): Promise<string>;
