import * as memoize from 'memoizee';
import type { AbstractSqlQuery, AbstractSqlModel, AbstractSqlTable, DurationNode, SelectNode, FromNode, WhereNode, OrderByNode, LimitNode, OffsetNode, NumberTypeNodes, FieldsNode, ValuesNode, ReferencedFieldNode, AliasNode, BooleanTypeNodes, SelectQueryNode, BindNode, TableNode, Definition as ModernDefinition, ResourceNode, UnionQueryNode, FromTypeNodes, FieldNode, CountNode, AddNode, InsertQueryNode, DeleteQueryNode, UpdateQueryNode, DurationTypeNodes, SubtractNode, MultiplyNode, DivideNode, NullNode, TextTypeNodes, AnyTypeNodes, StrictDateTypeNodes } from '@balena/abstract-sql-compiler';
import type { ODataBinds, ODataQuery, SupportedMethod, ExpandPropertyPath, ResourceOptions, OrderByOption, OrderByPropertyPath, FilterOption, BindReference } from '@balena/odata-parser';
export type { ODataBinds, ODataQuery, SupportedMethod };
type InternalSupportedMethod = Exclude<SupportedMethod, 'MERGE'> | 'PUT-INSERT';
type RequiredAbstractSqlModelSubset = Pick<AbstractSqlModel, 'synonyms' | 'relationships' | 'tables'>;
type Dictionary<T> = Record<string, T>;
interface LegacyDefinition {
    extraBinds: ODataBinds;
    abstractSqlQuery: SelectQueryNode | UnionQueryNode | ResourceNode | TableNode;
}
export type Definition = ModernDefinition | LegacyDefinition;
interface Resource extends Omit<AbstractSqlTable, 'definition'> {
    tableAlias?: string;
    definition?: Definition;
    resourceMappings?: {
        [odataName: string]: [tableAlias: string, fieldName: string];
    };
    modifyResourceMappings?: Resource['resourceMappings'];
}
type Overwrite<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;
type RequiredField<T, F extends keyof T> = Overwrite<T, Required<Pick<T, F>>>;
type AliasedResource = RequiredField<Resource, 'tableAlias'>;
export type ResourceFunction = (this: OData2AbstractSQL, property: {
    method: ['call', {
        method: string;
        args: any[];
    }];
    [key: string]: any;
}) => BooleanTypeNodes | {
    resource: Resource;
    name: string;
};
declare class Query {
    select: Array<ReferencedFieldNode | FieldNode | CountNode | AliasNode<SelectNode[1][number]>>;
    from: Array<FromNode[1]>;
    where: Array<WhereNode[1]>;
    extras: Array<FieldsNode | ValuesNode | OrderByNode | LimitNode | OffsetNode>;
    merge(otherQuery: Query): void;
    fromResource(odataToAbstractSql: OData2AbstractSQL, resource: AliasedResource, args?: {
        extraBindVars: ODataBinds;
        bindVarsLength: number;
    }, bypassDefinition?: boolean, isModifyOperation?: boolean): void;
    addNestedFieldSelect(fieldName: string, fieldNameAlias: string): void;
    compile(queryType: 'SelectQuery'): SelectQueryNode;
    compile(queryType: 'InsertQuery'): InsertQueryNode;
    compile(queryType: 'UpdateQuery'): UpdateQueryNode;
    compile(queryType: 'DeleteQuery'): DeleteQueryNode;
}
export declare const sqlNameToODataName: ((sqlName: string) => string) & memoize.Memoized<(sqlName: string) => string>;
export declare const odataNameToSqlName: ((odataName: string) => string) & memoize.Memoized<(odataName: string) => string>;
export declare const rewriteBinds: (definition: ModernDefinition, existingBinds: ODataBinds, inc?: number) => void;
export declare const isBindReference: (maybeBind: {
    [key: string]: unknown;
}) => maybeBind is BindReference;
export declare class OData2AbstractSQL {
    private clientModel;
    private methods;
    private extraBodyVars;
    extraBindVars: ODataBinds;
    private resourceAliases;
    defaultResource: Resource | undefined;
    bindVarsLength: number;
    private checkAlias;
    private alreadyComputedFields;
    constructor(clientModel: RequiredAbstractSqlModelSubset, methods?: Dictionary<ResourceFunction>, { minimizeAliases }?: {
        minimizeAliases?: boolean | undefined;
    });
    match(path: ODataQuery, $method: SupportedMethod, bodyKeys: string[], bindVarsLength: number, methods?: OData2AbstractSQL['methods']): {
        tree: AbstractSqlQuery;
        extraBodyVars: Dictionary<BindReference>;
        extraBindVars: ODataBinds;
    };
    PathSegment(method: InternalSupportedMethod, bodyKeys: string[], path: ODataQuery): Query;
    PathKey(method: InternalSupportedMethod, path: ODataQuery, resource: AliasedResource, bodyKeys: string[]): BooleanTypeNodes | undefined;
    Bind(bind: BindReference, optional: true): BindNode | undefined;
    Bind(bind: BindReference): BindNode;
    SelectFilter(filter: FilterOption, query: Query, resource: Resource): void;
    OrderBy(orderby: OrderByOption, query: Query, resource: Resource): void;
    OrderByProperties(orderings: OrderByPropertyPath[]): Array<OrderByNode[1]>;
    BindVars(method: InternalSupportedMethod, bodyKeys: string[], resourceName: string, match: Array<[string, [string, string]]>): Array<[string, 'Default' | BindNode]>;
    Resource(resourceName: string, parentResource?: Resource): AliasedResource;
    FieldContainedIn(fieldName: string, resource: Resource): boolean;
    ResourceMapping(resource: Resource, modifyFields?: boolean): NonNullable<Resource['resourceMappings']>;
    ResolveRelationship(resource: string | Resource, relationship: string): any;
    AddCountField(path: any, query: Query): void;
    AddSelectFields(path: any, query: Query, resource: Resource): void;
    AliasSelectField(resource: Resource, fieldName: string, computed?: AbstractSqlQuery, alias?: string, forceCompilingComputedField?: boolean): ReferencedFieldNode | AliasNode<ReferencedFieldNode> | AliasNode<AbstractSqlQuery>;
    ReferencedField(resource: Resource, resourceField: string): ReferencedFieldNode;
    BooleanMatch(match: any, optional: true): BooleanTypeNodes | undefined;
    BooleanMatch(match: any): BooleanTypeNodes;
    FunctionMatch<T extends string, U extends string>(name: T, match: any, sqlName: U): [U, ...AnyTypeNodes[]];
    FunctionMatch<T extends string>(name: T, match: any): [Capitalize<T>, ...AnyTypeNodes[]];
    Operand(match: any): BindNode | NullNode | BooleanTypeNodes | NumberTypeNodes | TextTypeNodes | StrictDateTypeNodes | DurationTypeNodes;
    Math(match: any): AddNode | SubtractNode | MultiplyNode | DivideNode | undefined;
    Lambda(resourceName: string, lambda: any): BooleanTypeNodes;
    ReferencedProperty(match: any): BooleanTypeNodes;
    Method(prop: unknown & {
        method: ['call', {
            method: string;
            args: any[];
        }];
    }): BooleanTypeNodes | {
        resource: Resource;
        name: string;
    };
    Property(prop: any): BooleanTypeNodes | {
        resource: Resource;
        name: string;
    };
    NumberMatch(match: any, optional: true): NumberTypeNodes | undefined;
    NumberMatch(match: any): NumberTypeNodes;
    NullMatch(match: any): NullNode | undefined;
    TextMatch(match: any, optional: true): TextTypeNodes | undefined;
    TextMatch(match: any): TextTypeNodes;
    DateMatch(match: any, optional: true): StrictDateTypeNodes | undefined;
    DateMatch(match: any): StrictDateTypeNodes;
    DurationMatch(match: DurationNode[1]): DurationTypeNodes | undefined;
    Expands(resource: Resource, query: Query, expands: ExpandPropertyPath[]): void;
    AddQueryOptions(resource: Resource, path: ResourceOptions, query: Query): void;
    NavigateResources(resource: Resource, navigation: string): {
        resource: AliasedResource;
        where: BooleanTypeNodes;
    };
    AddExtraFroms(query: Query, parentResource: Resource, match: any): void;
    AddNavigation(query: Query, resource: Resource, extraResource: string): AliasedResource;
    reset(): void;
    putReset(): void;
    Synonym(sqlName: string): string;
    getTableReference(resource: Resource, extraBindVars: ODataBinds, bindVarsLength: number, bypassDefinition?: boolean, tableAlias?: string, isModifyOperation?: boolean): FromTypeNodes;
    rewriteDefinition(definition: Definition, extraBindVars: ODataBinds, bindVarsLength: number): ModernDefinition;
}
