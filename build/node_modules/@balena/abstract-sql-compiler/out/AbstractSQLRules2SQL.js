"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSQLRules2SQL = exports.checkMinArgs = exports.checkArgs = exports.getAbstractSqlQuery = exports.isAbstractSqlQuery = exports.isNotNullable = exports.isFieldValue = exports.isDurationValue = exports.isJSONValue = exports.isArrayValue = exports.isDateValue = exports.isBooleanValue = exports.isNumericValue = exports.isTextValue = exports.comparisons = void 0;
const _ = require("lodash");
const sbvr_types_1 = require("@balena/sbvr-types");
let fieldOrderings = [];
let fieldOrderingsLookup = {};
let engine = "postgres";
let noBinds = false;
exports.comparisons = {
    Equals: ' = ',
    GreaterThan: ' > ',
    GreaterThanOrEqual: ' >= ',
    LessThan: ' < ',
    LessThanOrEqual: ' <= ',
    NotEquals: ' != ',
    Like: ' LIKE ',
};
const NestedIndent = (indent) => indent + '\t';
const escapeField = (field) => field === '*' ? '*' : `"${field}"`;
const AnyValue = (args, indent) => {
    const [type, ...rest] = args;
    if (type === 'Case') {
        return typeRules[type](rest, indent);
    }
    for (const matcher of [
        exports.isJSONValue,
        exports.isDateValue,
        exports.isTextValue,
        exports.isNumericValue,
        exports.isBooleanValue,
        exports.isDurationValue,
    ]) {
        if (matcher(type)) {
            return typeRules[type](rest, indent);
        }
    }
    return UnknownValue(args, indent);
};
const UnknownValue = (args, indent) => {
    const [type, ...rest] = args;
    switch (type) {
        case 'Null':
        case 'Field':
        case 'ReferencedField':
        case 'Bind':
        case 'Cast':
        case 'Coalesce':
        case 'ToJSON':
        case 'Any':
        case 'TextArray':
            return typeRules[type](rest, indent);
        case 'SelectQuery':
        case 'UnionQuery': {
            const nestedIndent = NestedIndent(indent);
            const query = typeRules[type](rest, nestedIndent);
            return '(' + nestedIndent + query + indent + ')';
        }
        default:
            throw new Error(`Invalid "UnknownValue" type: ${type}`);
    }
};
const MatchValue = (matcher) => (args, indent) => {
    const [type, ...rest] = args;
    if (matcher(type)) {
        return typeRules[type](rest, indent);
    }
    return UnknownValue(args, indent);
};
const isTextValue = (type) => {
    return (type === 'Text' ||
        type === 'EmbeddedText' ||
        type === 'Concatenate' ||
        type === 'ConcatenateWithSeparator' ||
        type === 'Lower' ||
        type === 'Upper' ||
        type === 'Trim' ||
        type === 'Replace' ||
        type === 'ExtractJSONPathAsText' ||
        type === 'Substring' ||
        type === 'Right' ||
        type === 'EscapeForLike');
};
exports.isTextValue = isTextValue;
const TextValue = MatchValue(exports.isTextValue);
const isNumericValue = (type) => {
    return (type === 'Number' ||
        type === 'Real' ||
        type === 'Integer' ||
        type === 'Add' ||
        type === 'Subtract' ||
        type === 'Multiply' ||
        type === 'Divide' ||
        type === 'BitwiseAnd' ||
        type === 'BitwiseShiftRight' ||
        type === 'CharacterLength' ||
        type === 'StrPos' ||
        type === 'Year' ||
        type === 'Month' ||
        type === 'Day' ||
        type === 'Hour' ||
        type === 'Minute' ||
        type === 'Second' ||
        type === 'Fractionalseconds' ||
        type === 'Totalseconds' ||
        type === 'Round' ||
        type === 'Floor' ||
        type === 'Ceiling' ||
        type === 'Count' ||
        type === 'Average' ||
        type === 'Sum' ||
        type === 'SubtractDateDate');
};
exports.isNumericValue = isNumericValue;
const NumericValue = MatchValue(exports.isNumericValue);
const isBooleanValue = (type) => {
    return (type === 'Boolean' ||
        type === 'Not' ||
        type === 'And' ||
        type === 'Or' ||
        type === 'Exists' ||
        type === 'NotExists' ||
        type === 'Between' ||
        type === 'In' ||
        type === 'NotIn' ||
        type === 'Equals' ||
        type === 'GreaterThan' ||
        type === 'GreaterThanOrEqual' ||
        type === 'LessThan' ||
        type === 'LessThanOrEqual' ||
        type === 'NotEquals' ||
        type === 'Like' ||
        type === 'IsNotDistinctFrom' ||
        type === 'IsDistinctFrom' ||
        type === 'StartsWith');
};
exports.isBooleanValue = isBooleanValue;
const BooleanValue = MatchValue(exports.isBooleanValue);
const isDateValue = (type) => {
    return (type === 'Date' ||
        type === 'ToDate' ||
        type === 'ToTime' ||
        type === 'CurrentTimestamp' ||
        type === 'CurrentDate' ||
        type === 'DateTrunc' ||
        type === 'AddDateNumber' ||
        type === 'AddDateDuration' ||
        type === 'SubtractDateDuration' ||
        type === 'SubtractDateNumber');
};
exports.isDateValue = isDateValue;
const DateValue = MatchValue(exports.isDateValue);
const isArrayValue = (type) => {
    return type === 'TextArray';
};
exports.isArrayValue = isArrayValue;
const isJSONValue = (type) => {
    return type === 'AggregateJSON' || type === 'ToJSON';
};
exports.isJSONValue = isJSONValue;
const JSONValue = MatchValue(exports.isJSONValue);
const isDurationValue = (type) => {
    return type === 'Duration';
};
exports.isDurationValue = isDurationValue;
const DurationValue = MatchValue(exports.isDurationValue);
const isFieldValue = (type) => {
    return type === 'Field' || type === 'ReferencedField';
};
exports.isFieldValue = isFieldValue;
const Field = (args, indent) => {
    const [type, ...rest] = args;
    if ((0, exports.isFieldValue)(type)) {
        return typeRules[type](rest, indent);
    }
    else {
        throw new SyntaxError(`Invalid field type: ${type}`);
    }
};
const isNotNullable = (node) => {
    switch (node[0]) {
        case 'EmbeddedText':
        case 'Boolean':
        case 'Bind':
        case 'Value':
        case 'Text':
        case 'Date':
        case 'Number':
        case 'Real':
        case 'Integer':
        case 'IsDistinctFrom':
        case 'IsNotDistinctFrom':
        case 'Exists':
        case 'NotExists':
            return true;
        case 'Coalesce':
            return node.slice(1).some((n) => (0, exports.isNotNullable)(n));
        case 'Not':
            return (0, exports.isNotNullable)(node[1]);
    }
    return false;
};
exports.isNotNullable = isNotNullable;
const isNotDistinctFrom = (args, indent) => {
    const a = (0, exports.getAbstractSqlQuery)(args, 0);
    const b = (0, exports.getAbstractSqlQuery)(args, 1);
    const aSql = AnyValue(a, indent);
    const bSql = AnyValue(b, indent);
    if (engine === "postgres") {
        const aIsNotNullable = (0, exports.isNotNullable)(a);
        const bIsNotNullable = (0, exports.isNotNullable)(b);
        if (aIsNotNullable && bIsNotNullable) {
            return `${aSql} = ${bSql}`;
        }
        const isNotNullChecks = [];
        if (!aIsNotNullable) {
            isNotNullChecks.push(`(${aSql}) IS NOT NULL`);
        }
        if (!bIsNotNullable) {
            isNotNullChecks.push(`(${bSql}) IS NOT NULL`);
        }
        const orBothNull = !aIsNotNullable && !bIsNotNullable
            ? ` OR (${aSql}) IS NULL AND (${bSql}) IS NULL`
            : '';
        return `${isNotNullChecks.join(' AND ')} AND (${aSql}) = (${bSql})${orBothNull}`;
    }
    else if (engine === "mysql") {
        return aSql + ' <=> ' + bSql;
    }
    else if (engine === "websql") {
        return aSql + ' IS ' + bSql;
    }
    else {
        throw new SyntaxError('IsDistinctFrom/IsNotDistinctFrom not supported on: ' + engine);
    }
};
const isAbstractSqlQuery = (x) => {
    return Array.isArray(x);
};
exports.isAbstractSqlQuery = isAbstractSqlQuery;
const getAbstractSqlQuery = (args, index) => {
    const abstractSqlQuery = args[index];
    if (!(0, exports.isAbstractSqlQuery)(abstractSqlQuery)) {
        throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof abstractSqlQuery}`);
    }
    return abstractSqlQuery;
};
exports.getAbstractSqlQuery = getAbstractSqlQuery;
const Comparison = (comparison) => {
    return (args, indent) => {
        (0, exports.checkArgs)(comparison, args, 2);
        const a = AnyValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const b = AnyValue((0, exports.getAbstractSqlQuery)(args, 1), indent);
        return a + exports.comparisons[comparison] + b;
    };
};
const NumberMatch = (type) => {
    return (args) => {
        (0, exports.checkArgs)(type, args, 1);
        const n = args[0];
        if (typeof n !== 'number') {
            throw new SyntaxError(`${type} expected number but got ${typeof n}`);
        }
        return `${n}`;
    };
};
const JoinMatch = (joinType) => {
    let sqlJoinType;
    switch (joinType) {
        case 'Join':
            sqlJoinType = 'JOIN ';
            break;
        case 'LeftJoin':
            sqlJoinType = 'LEFT JOIN ';
            break;
        case 'RightJoin':
            sqlJoinType = 'RIGHT JOIN ';
            break;
        case 'FullJoin':
            sqlJoinType = 'FULL JOIN ';
            break;
        case 'CrossJoin':
            sqlJoinType = 'CROSS JOIN ';
            break;
        default:
            throw new Error(`Unknown join type: '${joinType}'`);
    }
    return (args, indent) => {
        if (args.length !== 1 && args.length !== 2) {
            throw new SyntaxError(`"${joinType}" requires 1/2 arg(s)`);
        }
        const from = MaybeAlias((0, exports.getAbstractSqlQuery)(args, 0), indent, FromMatch);
        if (args.length === 1) {
            return sqlJoinType + from;
        }
        const [type, ...rest] = (0, exports.getAbstractSqlQuery)(args, 1);
        switch (type) {
            case 'On': {
                (0, exports.checkArgs)('On', rest, 1);
                const ruleBody = BooleanValue((0, exports.getAbstractSqlQuery)(rest, 0), NestedIndent(indent));
                return sqlJoinType + from + ' ON ' + ruleBody;
            }
            default:
                throw new SyntaxError(`'${joinType}' clause does not support '${type}' clause`);
        }
    };
};
const mathOps = {
    Add: '+',
    Subtract: '-',
    Multiply: '*',
    Divide: '/',
    BitwiseAnd: '&',
    BitwiseShiftRight: '>>',
};
const mathOperatorNodeTypes = new Set([
    ...Object.keys(mathOps),
    'AddDateDuration',
    'AddDateNumber',
    'SubtractDateDate',
    'SubtractDateDuration',
    'SubtractDateNumber',
]);
const mathOpValue = (valueMatchFn, args, index, indent) => {
    const operandAbstractSql = (0, exports.getAbstractSqlQuery)(args, index);
    const numericValue = valueMatchFn(operandAbstractSql, indent);
    const [childNodeType] = operandAbstractSql;
    if (mathOperatorNodeTypes.has(childNodeType)) {
        return `(${numericValue})`;
    }
    return numericValue;
};
const MathOp = (type) => {
    return (args, indent) => {
        (0, exports.checkArgs)(type, args, 2);
        const a = mathOpValue(NumericValue, args, 0, indent);
        const b = mathOpValue(NumericValue, args, 1, indent);
        return `${a} ${mathOps[type]} ${b}`;
    };
};
const fractionalSecondsFormat = function (date) {
    return this['Totalseconds'](date) + ' - ' + this['Second'](date);
};
const websqlBasicDateFormat = (format) => {
    return (date) => `STRFTIME('${format}', ${date})`;
};
const websqlDateFormats = {
    Year: websqlBasicDateFormat('%Y'),
    Month: websqlBasicDateFormat('%m'),
    Day: websqlBasicDateFormat('%d'),
    Hour: websqlBasicDateFormat('%H'),
    Minute: websqlBasicDateFormat('%M'),
    Second: websqlBasicDateFormat('%S'),
    Fractionalseconds: fractionalSecondsFormat,
    Totalseconds: websqlBasicDateFormat('%f'),
};
const basicDateFormat = function (part) {
    return (date) => `EXTRACT('${part}' FROM ${date})`;
};
const dateFormats = {
    Year: basicDateFormat('YEAR'),
    Month: basicDateFormat('MONTH'),
    Day: basicDateFormat('DAY'),
    Hour: basicDateFormat('HOUR'),
    Minute: basicDateFormat('MINUTE'),
    Second: (date) => `FLOOR(${dateFormats['Totalseconds'](date)})`,
    Fractionalseconds: fractionalSecondsFormat,
    Totalseconds: basicDateFormat('SECOND'),
};
const ExtractNumericDatePart = (type) => {
    return (args, indent) => {
        (0, exports.checkArgs)(type, args, 1);
        const date = DateValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        if (engine === "websql") {
            return websqlDateFormats[type](date);
        }
        else {
            return dateFormats[type](date);
        }
    };
};
const Text = (args) => {
    (0, exports.checkArgs)('Text', args, 1);
    if (noBinds) {
        return `'${args[0]}'`;
    }
    else {
        return AddBind(['Text', args[0]]);
    }
};
const checkArgs = (matchName, args, num) => {
    if (args.length !== num) {
        throw new SyntaxError(`"${matchName}" requires ${num} arg(s)`);
    }
};
exports.checkArgs = checkArgs;
const checkMinArgs = (matchName, args, num) => {
    if (args.length < num) {
        throw new SyntaxError(`"${matchName}" requires at least ${num} arg(s)`);
    }
};
exports.checkMinArgs = checkMinArgs;
const AddDateNumber = (args, indent) => {
    (0, exports.checkArgs)('AddDateNumber', args, 2);
    const a = mathOpValue(DateValue, args, 0, indent);
    const b = mathOpValue(NumericValue, args, 1, indent);
    if (engine === "postgres") {
        return `${a} + ${b}`;
    }
    else if (engine === "mysql") {
        return `ADDDATE(${a}, ${b})`;
    }
    else {
        throw new SyntaxError('AddDateNumber not supported on: ' + engine);
    }
};
const AddDateDuration = (args, indent) => {
    (0, exports.checkArgs)('AddDateDuration', args, 2);
    const a = mathOpValue(DateValue, args, 0, indent);
    const b = mathOpValue(DurationValue, args, 1, indent);
    if (engine === "postgres") {
        return `${a} + ${b}`;
    }
    else if (engine === "mysql") {
        return `DATE_ADD(${a}, ${b})`;
    }
    else {
        throw new SyntaxError('AddDateDuration not supported on: ' + engine);
    }
};
const SubtractDateDuration = (args, indent) => {
    (0, exports.checkArgs)('SubtractDateDuration', args, 2);
    const a = mathOpValue(DateValue, args, 0, indent);
    const b = mathOpValue(DurationValue, args, 1, indent);
    if (engine === "postgres") {
        return `${a} - ${b}`;
    }
    else if (engine === "mysql") {
        return `DATE_SUB(${a}, ${b})`;
    }
    else {
        throw new SyntaxError('SubtractDateDuration not supported on: ' + engine);
    }
};
const SubtractDateNumber = (args, indent) => {
    (0, exports.checkArgs)('SubtractDateNumber', args, 2);
    const a = mathOpValue(DateValue, args, 0, indent);
    const b = mathOpValue(NumericValue, args, 1, indent);
    if (engine === "postgres") {
        return `${a} - ${b}`;
    }
    else if (engine === "mysql") {
        return `SUBDATE(${a}, ${b})`;
    }
    else {
        throw new SyntaxError('SubtractDateNumber not supported on: ' + engine);
    }
};
const SubtractDateDate = (args, indent) => {
    (0, exports.checkArgs)('SubtractDateDate', args, 2);
    const a = mathOpValue(DateValue, args, 0, indent);
    const b = mathOpValue(DateValue, args, 1, indent);
    if (engine === "postgres") {
        return `${a} - ${b}`;
    }
    else if (engine === "mysql") {
        return `DATEDIFF(${a}, ${b})`;
    }
    else {
        throw new SyntaxError('SubtractDateDate not supported on: ' + engine);
    }
};
const Value = (arg, indent) => {
    switch (arg) {
        case 'Default':
            return 'DEFAULT';
        default: {
            const [type, ...rest] = arg;
            switch (type) {
                case 'Null':
                case 'Bind':
                case 'Value':
                case 'Text':
                case 'Number':
                case 'Real':
                case 'Integer':
                case 'Boolean':
                    return typeRules[type](rest, indent);
                default:
                    throw new SyntaxError(`Invalid type for Value ${type}`);
            }
        }
    }
};
const SelectMatch = (args, indent) => {
    const [type, ...rest] = args;
    switch (type) {
        case 'Count':
            return typeRules[type](rest, indent);
        default:
            return AnyValue(args, indent);
    }
};
const FromMatch = (args, indent) => {
    const [type, ...rest] = args;
    switch (type) {
        case 'SelectQuery':
        case 'UnionQuery': {
            const nestedindent = NestedIndent(indent);
            const query = typeRules[type](rest, nestedindent);
            return '(' + nestedindent + query + indent + ')';
        }
        case 'Table': {
            (0, exports.checkArgs)('Table', rest, 1);
            const [table] = rest;
            if (typeof table !== 'string') {
                throw new SyntaxError('`Table` table must be a string');
            }
            return escapeField(table);
        }
        default:
            throw new SyntaxError(`From does not support ${type}`);
    }
};
const MaybeAlias = (args, indent, matchFn) => {
    const [type, ...rest] = args;
    switch (type) {
        case 'Alias': {
            (0, exports.checkArgs)('Alias', rest, 2);
            const field = matchFn((0, exports.getAbstractSqlQuery)(rest, 0), indent);
            return `${field} AS "${rest[1]}"`;
        }
        default:
            return matchFn(args, indent);
    }
};
const AddBind = (bind) => {
    if (noBinds) {
        throw new SyntaxError('Cannot use a bind whilst they are disabled');
    }
    if (engine === "postgres") {
        if (bind[0] === 'Bind') {
            const key = JSON.stringify(bind[1]);
            const existingBindIndex = fieldOrderingsLookup[key];
            if (existingBindIndex != null) {
                return '$' + existingBindIndex;
            }
            const nextID = fieldOrderings.push(bind);
            fieldOrderingsLookup[key] = nextID;
            return '$' + nextID;
        }
        return '$' + fieldOrderings.push(bind);
    }
    else {
        fieldOrderings.push(bind);
        return '?';
    }
};
const typeRules = {
    UnionQuery: (args, indent) => {
        (0, exports.checkMinArgs)('UnionQuery', args, 2);
        return args
            .map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            const [type, ...rest] = arg;
            switch (type) {
                case 'SelectQuery':
                case 'UnionQuery':
                    return typeRules[type](rest, indent);
                default:
                    throw new SyntaxError(`UnionQuery does not support ${type}`);
            }
        })
            .join(indent + 'UNION' + indent);
    },
    SelectQuery: (args, indent) => {
        const tables = [];
        const joins = [];
        let select = '';
        const groups = {
            Where: '',
            GroupBy: '',
            Having: '',
            OrderBy: '',
            Limit: '',
            Offset: '',
        };
        for (const arg of args) {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError('`SelectQuery` args must all be arrays');
            }
            const [type, ...rest] = arg;
            switch (type) {
                case 'Select':
                    if (select !== '') {
                        throw new SyntaxError(`'SelectQuery' can only accept one '${type}'`);
                    }
                    select = typeRules[type](rest, indent);
                    break;
                case 'From':
                    tables.push(typeRules[type](rest, indent));
                    break;
                case 'Join':
                case 'LeftJoin':
                case 'RightJoin':
                case 'FullJoin':
                case 'CrossJoin':
                    joins.push(typeRules[type](rest, indent));
                    break;
                case 'Where':
                case 'GroupBy':
                case 'Having':
                case 'OrderBy':
                case 'Limit':
                case 'Offset':
                    if (groups[type] !== '') {
                        throw new SyntaxError(`'SelectQuery' can only accept one '${type}'`);
                    }
                    groups[type] = indent + typeRules[type](rest, indent);
                    break;
                default:
                    throw new SyntaxError(`'SelectQuery' does not support '${type}'`);
            }
        }
        if (tables.length === 0 && joins.length > 0) {
            throw new SyntaxError('Must have at least one From node in order to use Join nodes');
        }
        const from = tables.length > 0
            ? indent + 'FROM ' + tables.join(',' + NestedIndent(indent))
            : '';
        const joinStr = joins.length > 0 ? indent + joins.join(indent) : '';
        return ('SELECT ' +
            select +
            from +
            joinStr +
            groups.Where +
            groups.GroupBy +
            groups.Having +
            groups.OrderBy +
            groups.Limit +
            groups.Offset);
    },
    Select: (args, indent) => {
        (0, exports.checkArgs)('Select', args, 1);
        args = (0, exports.getAbstractSqlQuery)(args, 0);
        if (args.length === 0) {
            return '1';
        }
        return args
            .map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return MaybeAlias(arg, indent, SelectMatch);
        })
            .join(', ');
    },
    From: (args, indent) => {
        (0, exports.checkArgs)('From', args, 1);
        return MaybeAlias((0, exports.getAbstractSqlQuery)(args, 0), indent, FromMatch);
    },
    Join: JoinMatch('Join'),
    LeftJoin: JoinMatch('LeftJoin'),
    RightJoin: JoinMatch('RightJoin'),
    FullJoin: JoinMatch('FullJoin'),
    CrossJoin: (args, indent) => {
        (0, exports.checkArgs)('CrossJoin', args, 1);
        const from = MaybeAlias((0, exports.getAbstractSqlQuery)(args, 0), indent, FromMatch);
        return `CROSS JOIN ${from}`;
    },
    Where: (args, indent) => {
        (0, exports.checkArgs)('Where', args, 1);
        const boolNode = (0, exports.getAbstractSqlQuery)(args, 0);
        if (boolNode[0] === 'Boolean') {
            return `WHERE ${boolNode[1] ? 'true' : 'false'}`;
        }
        const ruleBody = BooleanValue(boolNode, indent);
        return 'WHERE ' + ruleBody;
    },
    GroupBy: (args, indent) => {
        (0, exports.checkArgs)('GroupBy', args, 1);
        const groups = (0, exports.getAbstractSqlQuery)(args, 0);
        (0, exports.checkMinArgs)('GroupBy groups', groups, 1);
        return ('GROUP BY ' +
            groups.map((arg) => AnyValue(arg, indent)).join(', '));
    },
    Having: (args, indent) => {
        (0, exports.checkArgs)('Having', args, 1);
        const havingBody = BooleanValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `HAVING ${havingBody}`;
    },
    OrderBy: (args, indent) => {
        (0, exports.checkMinArgs)('OrderBy', args, 1);
        return ('ORDER BY ' +
            args
                .map((arg) => {
                (0, exports.checkMinArgs)('OrderBy ordering', arg, 2);
                const order = arg[0];
                if (order !== 'ASC' && order !== 'DESC') {
                    throw new SyntaxError(`Can only order by "ASC" or "DESC"`);
                }
                const value = AnyValue((0, exports.getAbstractSqlQuery)(arg, 1), indent);
                return `${value} ${order}`;
            })
                .join(',' + NestedIndent(indent)));
    },
    Limit: (args, indent) => {
        (0, exports.checkArgs)('Limit', args, 1);
        const num = NumericValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `LIMIT ${num}`;
    },
    Offset: (args, indent) => {
        (0, exports.checkArgs)('Offset', args, 1);
        const num = NumericValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `OFFSET ${num}`;
    },
    Count: (args) => {
        (0, exports.checkArgs)('Count', args, 1);
        if (args[0] !== '*') {
            throw new SyntaxError('"Count" only supports "*"');
        }
        return 'COUNT(*)';
    },
    Average: (args, indent) => {
        (0, exports.checkArgs)('Average', args, 1);
        const num = NumericValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `AVG(${num})`;
    },
    Sum: (args, indent) => {
        (0, exports.checkArgs)('Sum', args, 1);
        const num = NumericValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `SUM(${num})`;
    },
    Field: (args) => {
        (0, exports.checkArgs)('Field', args, 1);
        const [field] = args;
        if (typeof field !== 'string') {
            throw new SyntaxError('`Field` field must be a string');
        }
        return escapeField(field);
    },
    ReferencedField: (args) => {
        (0, exports.checkArgs)('ReferencedField', args, 2);
        const [table, field] = args;
        if (typeof table !== 'string') {
            throw new SyntaxError('`ReferencedField` table must be a string');
        }
        if (typeof field !== 'string') {
            throw new SyntaxError('`ReferencedField` field must be a string');
        }
        return `"${table}".${escapeField(field)}`;
    },
    Cast: (args, indent) => {
        (0, exports.checkArgs)('Cast', args, 2);
        const value = AnyValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const typeName = args[1];
        if (!sbvr_types_1.default[typeName] || !sbvr_types_1.default[typeName].types[engine]) {
            throw new SyntaxError(`Invalid cast type: ${typeName}`);
        }
        let type;
        const dbType = sbvr_types_1.default[typeName].types[engine];
        if (typeof dbType === 'function') {
            type = dbType.castType;
        }
        else if (dbType.toUpperCase() === 'SERIAL') {
            type = 'INTEGER';
        }
        else if (dbType.toUpperCase() === 'BIGSERIAL') {
            type = 'BIGINT';
        }
        else {
            type = dbType;
        }
        return `CAST(${value} AS ${type})`;
    },
    Number: NumberMatch('Number'),
    Real: NumberMatch('Real'),
    Integer: NumberMatch('Integer'),
    Boolean: (args) => {
        (0, exports.checkArgs)('Boolean', args, 1);
        const b = args[0];
        if (typeof b !== 'boolean') {
            throw new SyntaxError(`Boolean expected boolean but got ${typeof b}`);
        }
        return b ? 'TRUE' : 'FALSE';
    },
    EmbeddedText: (args) => {
        (0, exports.checkArgs)('EmbeddedText', args, 1);
        return `'${args[0]}'`;
    },
    TextArray: (args, indent) => {
        const values = args.map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return TextValue(arg, indent);
        });
        return values.length
            ? `ARRAY[${values.join(', ')}]`
            : 'CAST(ARRAY[] as TEXT[])';
    },
    Null: (args) => {
        (0, exports.checkArgs)('Null', args, 0);
        return 'NULL';
    },
    CurrentTimestamp: (args) => {
        (0, exports.checkArgs)('CurrentTimestamp', args, 0);
        return 'CURRENT_TIMESTAMP';
    },
    CurrentDate: (args) => {
        (0, exports.checkArgs)('CurrentDate', args, 0);
        return 'CURRENT_DATE';
    },
    AggregateJSON: (args, indent) => {
        (0, exports.checkArgs)('AggregateJSON', args, 1);
        if (engine !== "postgres") {
            throw new SyntaxError('AggregateJSON not supported on: ' + engine);
        }
        const field = Field((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `COALESCE(JSON_AGG(${field}), '[]')`;
    },
    Equals: Comparison('Equals'),
    GreaterThan: Comparison('GreaterThan'),
    GreaterThanOrEqual: Comparison('GreaterThanOrEqual'),
    LessThan: Comparison('LessThan'),
    LessThanOrEqual: Comparison('LessThanOrEqual'),
    NotEquals: Comparison('NotEquals'),
    Like: Comparison('Like'),
    IsNotDistinctFrom: (args, indent) => {
        (0, exports.checkArgs)('IsNotDistinctFrom', args, 2);
        return isNotDistinctFrom(args, indent);
    },
    IsDistinctFrom: (args, indent) => {
        (0, exports.checkArgs)('IsDistinctFrom', args, 2);
        return 'NOT(' + isNotDistinctFrom(args, indent) + ')';
    },
    Between: (args, indent) => {
        (0, exports.checkArgs)('Between', args, 3);
        const v = AnyValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const a = AnyValue((0, exports.getAbstractSqlQuery)(args, 1), indent);
        const b = AnyValue((0, exports.getAbstractSqlQuery)(args, 2), indent);
        return `${v} BETWEEN ${a} AND (${b})`;
    },
    Add: MathOp('Add'),
    Subtract: MathOp('Subtract'),
    Multiply: MathOp('Multiply'),
    Divide: MathOp('Divide'),
    BitwiseAnd: MathOp('BitwiseAnd'),
    BitwiseShiftRight: MathOp('BitwiseShiftRight'),
    AddDateNumber,
    AddDateDuration,
    SubtractDateDate,
    SubtractDateNumber,
    SubtractDateDuration,
    Year: ExtractNumericDatePart('Year'),
    Month: ExtractNumericDatePart('Month'),
    Day: ExtractNumericDatePart('Day'),
    Hour: ExtractNumericDatePart('Hour'),
    Minute: ExtractNumericDatePart('Minute'),
    Second: ExtractNumericDatePart('Second'),
    Fractionalseconds: ExtractNumericDatePart('Fractionalseconds'),
    Totalseconds: (args, indent) => {
        (0, exports.checkArgs)('Totalseconds', args, 1);
        const duration = DurationValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        if (engine === "postgres") {
            return `EXTRACT(EPOCH FROM ${duration})`;
        }
        else if (engine === "mysql") {
            return `(TIMESTAMPDIFF(MICROSECOND, FROM_UNIXTIME(0), FROM_UNIXTIME(0) + ${duration}) / 1000000)`;
        }
        else {
            throw new SyntaxError('TotalSeconds not supported on: ' + engine);
        }
    },
    Concatenate: (args, indent) => {
        (0, exports.checkMinArgs)('Concatenate', args, 1);
        const comparators = args.map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return TextValue(arg, indent);
        });
        if (engine === "mysql") {
            return 'CONCAT(' + comparators.join(', ') + ')';
        }
        else {
            return '(' + comparators.join(' || ') + ')';
        }
    },
    ConcatenateWithSeparator: (args, indent) => {
        (0, exports.checkMinArgs)('ConcatenateWithSeparator', args, 2);
        const textParts = args.map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return TextValue(arg, indent);
        });
        if (engine === "websql") {
            throw new SyntaxError('ConcatenateWithSeparator not supported on: ' + engine);
        }
        return `CONCAT_WS(${textParts.join(', ')})`;
    },
    Replace: (args, indent) => {
        (0, exports.checkArgs)('Replace', args, 3);
        const str = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const find = TextValue((0, exports.getAbstractSqlQuery)(args, 1), indent);
        const replacement = TextValue((0, exports.getAbstractSqlQuery)(args, 2), indent);
        return `REPLACE(${str}, ${find}, ${replacement})`;
    },
    ExtractJSONPathAsText: (args, indent) => {
        (0, exports.checkMinArgs)('ExtractJSONPathAsText', args, 1);
        if (engine !== "postgres") {
            throw new SyntaxError('ExtractJSONPathAsText not supported on: ' + engine);
        }
        const json = JSONValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const path = TextValue((0, exports.getAbstractSqlQuery)(args, 1), indent);
        return `${json} #>> ${path}`;
    },
    CharacterLength: (args, indent) => {
        (0, exports.checkArgs)('CharacterLength', args, 1);
        const text = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        if (engine === "mysql") {
            return `CHAR_LENGTH(${text})`;
        }
        else {
            return `LENGTH(${text})`;
        }
    },
    StrPos: (args, indent) => {
        (0, exports.checkArgs)('StrPos', args, 2);
        const haystack = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const needle = TextValue((0, exports.getAbstractSqlQuery)(args, 1), indent);
        if (engine === "postgres") {
            return `STRPOS(${haystack}, ${needle})`;
        }
        else {
            return `INSTR(${haystack}, ${needle})`;
        }
    },
    StartsWith: (args, indent) => {
        (0, exports.checkArgs)('StartsWith', args, 2);
        const haystack = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const needle = TextValue((0, exports.getAbstractSqlQuery)(args, 1), indent);
        if (engine === "postgres") {
            return `STARTS_WITH(${haystack}, ${needle})`;
        }
        else {
            return typeRules.Like([
                haystack,
                ['Concatenate', ['EscapeForLike', needle], ['EmbeddedText', '%']],
            ], indent);
        }
    },
    Substring: (args, indent) => {
        (0, exports.checkMinArgs)('Substring', args, 2);
        const str = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const nums = args.slice(1).map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return NumericValue(arg, indent);
        });
        return `SUBSTRING(${[str, ...nums].join(', ')})`;
    },
    Right: (args, indent) => {
        (0, exports.checkArgs)('Right', args, 2);
        const str = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const n = NumericValue((0, exports.getAbstractSqlQuery)(args, 1), indent);
        if (engine === "websql") {
            return `SUBSTRING(${str}, -${n})`;
        }
        else {
            return `RIGHT(${str}, ${n})`;
        }
    },
    Lower: (args, indent) => {
        (0, exports.checkArgs)('Lower', args, 1);
        const str = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `LOWER(${str})`;
    },
    Upper: (args, indent) => {
        (0, exports.checkArgs)('Upper', args, 1);
        const str = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `UPPER(${str})`;
    },
    Trim: (args, indent) => {
        (0, exports.checkArgs)('Trim', args, 1);
        const str = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `TRIM(${str})`;
    },
    Round: (args, indent) => {
        (0, exports.checkArgs)('Round', args, 1);
        const num = NumericValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `ROUND(${num})`;
    },
    Floor: (args, indent) => {
        (0, exports.checkArgs)('Floor', args, 1);
        const num = NumericValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `FLOOR(${num})`;
    },
    Ceiling: (args, indent) => {
        (0, exports.checkArgs)('Ceiling', args, 1);
        const num = NumericValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `CEILING(${num})`;
    },
    ToDate: (args, indent) => {
        (0, exports.checkArgs)('ToDate', args, 1);
        const date = DateValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `DATE(${date})`;
    },
    DateTrunc: (args, indent) => {
        (0, exports.checkArgs)('DateTrunc', args, 2);
        const precision = TextValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const date = DateValue((0, exports.getAbstractSqlQuery)(args, 1), indent);
        if (engine === "postgres") {
            return `DATE_TRUNC(${precision}, ${date})`;
        }
        else if (precision === "'milliseconds'" ||
            precision === "'microseconds'") {
            return date;
        }
        else {
            throw new SyntaxError('DateTrunc is not supported on: ' + engine);
        }
    },
    ToTime: (args, indent) => {
        (0, exports.checkArgs)('ToTime', args, 1);
        const date = DateValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        if (engine === "postgres") {
            return `CAST(${date} AS TIME)`;
        }
        else {
            return `TIME(${date})`;
        }
    },
    ToJSON: (args, indent) => {
        (0, exports.checkMinArgs)('ToJSON', args, 1);
        if (engine !== "postgres") {
            throw new SyntaxError('ToJSON not supported on: ' + engine);
        }
        const value = AnyValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        return `TO_JSON(${value})`;
    },
    Any: (args, indent) => {
        (0, exports.checkArgs)('Any', args, 2);
        if (engine !== "postgres") {
            throw new SyntaxError('Any not supported on: ' + engine);
        }
        const value = AnyValue((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const innerType = sbvr_types_1.default[args[1]].types[engine];
        return `ANY(CAST(${value} AS ${innerType}[]))`;
    },
    Coalesce: (args, indent) => {
        (0, exports.checkMinArgs)('Coalesce', args, 2);
        const comparators = args.map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return AnyValue(arg, indent);
        });
        return 'COALESCE(' + comparators.join(', ') + ')';
    },
    Case: (args, indent) => {
        (0, exports.checkMinArgs)('Case', args, 1);
        const nestedIndent = NestedIndent(indent);
        const clauses = args
            .map((arg, index) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            const [type, ...rest] = arg;
            switch (type) {
                case 'When': {
                    (0, exports.checkArgs)('When', rest, 2);
                    const matches = BooleanValue((0, exports.getAbstractSqlQuery)(rest, 0), NestedIndent(nestedIndent));
                    const resultValue = AnyValue((0, exports.getAbstractSqlQuery)(rest, 1), nestedIndent);
                    return 'WHEN ' + matches + ' THEN ' + resultValue;
                }
                case 'Else':
                    if (index !== args.length - 1) {
                        throw new SyntaxError('Else must be the last element of a Case');
                    }
                    (0, exports.checkArgs)('Else', rest, 1);
                    return ('ELSE ' + AnyValue((0, exports.getAbstractSqlQuery)(rest, 0), nestedIndent));
                default:
                    throw new SyntaxError('Case can only contain When/Else');
            }
        })
            .join(nestedIndent);
        return 'CASE' + nestedIndent + clauses + indent + 'END';
    },
    And: (args, indent) => {
        (0, exports.checkMinArgs)('And', args, 2);
        return args
            .map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return BooleanValue(arg, indent);
        })
            .join(indent + 'AND ');
    },
    Or: (args, indent) => {
        (0, exports.checkMinArgs)('Or', args, 2);
        return ('(' +
            args
                .map((arg) => {
                if (!(0, exports.isAbstractSqlQuery)(arg)) {
                    throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
                }
                return BooleanValue(arg, indent);
            })
                .join(indent + 'OR ') +
            ')');
    },
    Bind: (args) => {
        let bind;
        if (args.length === 2) {
            bind = args;
        }
        else if (args.length === 1) {
            bind = args[0];
        }
        else {
            throw new SyntaxError(`"Bind" requires 1/2 arg(s)`);
        }
        return AddBind(['Bind', bind]);
    },
    Text,
    Date: (args) => {
        (0, exports.checkArgs)('Date', args, 1);
        return AddBind(['Date', args[0]]);
    },
    Duration: (args) => {
        (0, exports.checkArgs)('Duration', args, 1);
        if (engine === "websql") {
            throw new SyntaxError('Durations not supported on: ' + engine);
        }
        let duration = args[0];
        if (duration == null || typeof duration !== 'object') {
            throw new SyntaxError(`Duration must be an object, got ${typeof duration}`);
        }
        duration = _(duration)
            .pick('negative', 'day', 'hour', 'minute', 'second')
            .omitBy(_.isNil)
            .value();
        if (_(duration).omit('negative').isEmpty()) {
            throw new SyntaxError('Invalid duration');
        }
        return ("INTERVAL '" +
            (duration.negative ? '-' : '') +
            (duration.day ?? '0') +
            ' ' +
            (duration.negative ? '-' : '') +
            (duration.hour ?? '0') +
            ':' +
            (duration.minute ?? '0') +
            ':' +
            Number(duration.second ?? 0).toLocaleString('en', {
                minimumFractionDigits: 1,
            }) +
            "'" +
            (engine === "mysql" ? ' DAY_MICROSECOND' : ''));
    },
    Exists: (args, indent) => {
        (0, exports.checkArgs)('Exists', args, 1);
        const arg = (0, exports.getAbstractSqlQuery)(args, 0);
        const [type, ...rest] = arg;
        switch (type) {
            case 'SelectQuery':
            case 'UnionQuery': {
                const nestedIndent = NestedIndent(indent);
                const query = typeRules[type](rest, nestedIndent);
                return 'EXISTS (' + nestedIndent + query + indent + ')';
            }
            default:
                return AnyValue(arg, indent) + ' IS NOT NULL';
        }
    },
    NotExists: (args, indent) => {
        (0, exports.checkArgs)('NotExists', args, 1);
        const arg = (0, exports.getAbstractSqlQuery)(args, 0);
        const [type, ...rest] = arg;
        switch (type) {
            case 'SelectQuery':
            case 'UnionQuery': {
                const nestedIndent = NestedIndent(indent);
                const query = typeRules[type](rest, nestedIndent);
                return 'NOT EXISTS (' + nestedIndent + query + indent + ')';
            }
            default:
                return AnyValue(arg, indent) + ' IS NULL';
        }
    },
    Not: (args, indent) => {
        (0, exports.checkArgs)('Not', args, 1);
        const nestedIndent = NestedIndent(indent);
        const bool = BooleanValue((0, exports.getAbstractSqlQuery)(args, 0), nestedIndent);
        return 'NOT (' + nestedIndent + bool + indent + ')';
    },
    In: (args, indent) => {
        (0, exports.checkMinArgs)('In', args, 2);
        const field = Field((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const vals = args.slice(1).map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return AnyValue(arg, indent);
        });
        return field + ' IN (' + vals.join(', ') + ')';
    },
    NotIn: (args, indent) => {
        (0, exports.checkMinArgs)('NotIn', args, 2);
        const field = Field((0, exports.getAbstractSqlQuery)(args, 0), indent);
        const vals = args.slice(1).map((arg) => {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError(`Expected AbstractSqlQuery array but got ${typeof arg}`);
            }
            return AnyValue(arg, indent);
        });
        return field + ' NOT IN (' + vals.join(', ') + ')';
    },
    InsertQuery: (args, indent) => {
        const tables = [];
        let fields = [];
        let values = [];
        for (const arg of args) {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError('`InsertQuery` args must all be arrays');
            }
            const [type, ...rest] = arg;
            switch (type) {
                case 'Fields':
                    if (fields.length !== 0) {
                        throw new SyntaxError(`'InsertQuery' can only accept one '${type}'`);
                    }
                    (0, exports.checkMinArgs)('Update fields', rest, 1);
                    fields = (0, exports.getAbstractSqlQuery)(rest, 0).map(escapeField);
                    break;
                case 'Values': {
                    if (values.length !== 0) {
                        throw new SyntaxError(`'InsertQuery' can only accept one '${type}'`);
                    }
                    const valuesArray = (0, exports.getAbstractSqlQuery)(rest, 0);
                    if (valuesArray.length > 0) {
                        const [valuesType, ...valuesRest] = valuesArray;
                        switch (valuesType) {
                            case 'SelectQuery':
                            case 'UnionQuery':
                                values = typeRules[valuesType](valuesRest, indent);
                                break;
                            default:
                                values = valuesArray.map((v) => Value(v, indent));
                        }
                    }
                    break;
                }
                case 'From':
                    tables.push(typeRules[type](rest, indent));
                    break;
                default:
                    throw new SyntaxError(`'InsertQuery' does not support '${type}'`);
            }
        }
        if (typeof values !== 'string' && fields.length !== values.length) {
            throw new SyntaxError('Fields and Values must have the same length or use a query');
        }
        if (fields.length > 0) {
            if (Array.isArray(values)) {
                values = 'VALUES (' + values.join(', ') + ')';
            }
            return ('INSERT INTO ' +
                tables.join(', ') +
                ' (' +
                fields.join(', ') +
                ')' +
                indent +
                values);
        }
        else {
            return 'INSERT INTO ' + tables.join(', ') + ' DEFAULT VALUES';
        }
    },
    UpdateQuery: (args, indent) => {
        const tables = [];
        let fields = [];
        let values = [];
        let where = '';
        for (const arg of args) {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError('`UpdateQuery` args must all be arrays');
            }
            const [type, ...rest] = arg;
            switch (type) {
                case 'Fields':
                    if (fields.length !== 0) {
                        throw new SyntaxError(`'UpdateQuery' can only accept one '${type}'`);
                    }
                    (0, exports.checkMinArgs)('Update fields', rest, 1);
                    fields = (0, exports.getAbstractSqlQuery)(rest, 0).map(escapeField);
                    break;
                case 'Values': {
                    if (values.length !== 0) {
                        throw new SyntaxError(`'UpdateQuery' can only accept one '${type}'`);
                    }
                    (0, exports.checkArgs)('Update values', rest, 1);
                    const valuesArray = (0, exports.getAbstractSqlQuery)(rest, 0);
                    (0, exports.checkMinArgs)('Update values array', valuesArray, 1);
                    values = valuesArray.map((v) => Value(v, indent));
                    break;
                }
                case 'From':
                    tables.push(typeRules[type](rest, indent));
                    break;
                case 'Where':
                    if (where !== '') {
                        throw new SyntaxError(`'UpdateQuery' can only accept one '${type}'`);
                    }
                    where = indent + typeRules[type](rest, indent);
                    break;
                default:
                    throw new SyntaxError(`'UpdateQuery' does not support '${type}'`);
            }
        }
        if (fields.length !== values.length) {
            throw new SyntaxError('Fields and Values must have the same length');
        }
        const sets = fields.map((field, i) => field + ' = ' + values[i]);
        return ('UPDATE ' +
            tables.join(', ') +
            indent +
            'SET ' +
            sets.join(',' + NestedIndent(indent)) +
            where);
    },
    DeleteQuery: (args, indent) => {
        const tables = [];
        let where = '';
        for (const arg of args) {
            if (!(0, exports.isAbstractSqlQuery)(arg)) {
                throw new SyntaxError('`DeleteQuery` args must all be arrays');
            }
            const [type, ...rest] = arg;
            switch (type) {
                case 'From':
                    tables.push(typeRules[type](rest, indent));
                    break;
                case 'Where':
                    if (where !== '') {
                        throw new SyntaxError(`'DeleteQuery' can only accept one '${type}'`);
                    }
                    where = indent + typeRules[type](rest, indent);
                    break;
                default:
                    throw new SyntaxError(`'DeleteQuery' does not support '${type}'`);
            }
        }
        return 'DELETE FROM ' + tables.join(', ') + where;
    },
    EscapeForLike: (args, indent) => {
        (0, exports.checkArgs)('EscapeForLike', args, 1);
        const textTypeNode = (0, exports.getAbstractSqlQuery)(args, 0);
        return typeRules.Replace([
            [
                'Replace',
                [
                    'Replace',
                    textTypeNode,
                    ['EmbeddedText', '\\'],
                    ['EmbeddedText', '\\\\'],
                ],
                ['EmbeddedText', '_'],
                ['EmbeddedText', '\\_'],
            ],
            ['EmbeddedText', '%'],
            ['EmbeddedText', '\\%'],
        ], indent);
    },
};
const toSqlResult = (query) => {
    if (noBinds) {
        return query;
    }
    return {
        query,
        bindings: fieldOrderings,
    };
};
function AbstractSQLRules2SQL(abstractSQL, $engine, $noBinds = false) {
    engine = $engine;
    noBinds = $noBinds;
    fieldOrderings = [];
    fieldOrderingsLookup = {};
    const indent = '\n';
    const [type, ...rest] = abstractSQL;
    switch (type) {
        case 'SelectQuery':
        case 'UnionQuery':
        case 'InsertQuery':
        case 'UpdateQuery':
        case 'DeleteQuery': {
            const query = typeRules[type](rest, indent);
            return toSqlResult(query);
        }
        case 'UpsertQuery': {
            (0, exports.checkArgs)('UpsertQuery', rest, 2);
            const insertQuery = (0, exports.getAbstractSqlQuery)(rest, 0);
            const updateQuery = (0, exports.getAbstractSqlQuery)(rest, 1);
            if (insertQuery[0] !== 'InsertQuery' ||
                updateQuery[0] !== 'UpdateQuery') {
                throw new SyntaxError('UpsertQuery must have [InsertQuery, UpdateQuery] provided');
            }
            const insertSql = typeRules.InsertQuery(insertQuery.slice(1), indent);
            const insert = toSqlResult(insertSql);
            fieldOrderings = [];
            fieldOrderingsLookup = {};
            const updateSql = typeRules.UpdateQuery(updateQuery.slice(1), indent);
            const update = toSqlResult(updateSql);
            return [insert, update];
        }
        default: {
            const value = AnyValue(abstractSQL, indent);
            if (noBinds) {
                return value;
            }
            return {
                query: `SELECT ${value} AS "result";`,
                bindings: fieldOrderings,
            };
        }
    }
}
exports.AbstractSQLRules2SQL = AbstractSQLRules2SQL;
//# sourceMappingURL=AbstractSQLRules2SQL.js.map